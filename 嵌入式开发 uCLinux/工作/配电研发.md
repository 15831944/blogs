# 软件需要采集的模拟量数据的类型

RMS                      均方根值         电流电压有效值 root meam square
True Power            有效功率
Apparent Power      视在功率
Complex Power      复数功率
Power Factor          功率因数
Phase Angle            相位角
Neutral Current       中性线电流
Temperature DC
Future DC
Real energy
Reactive Energy      无功电能

# 编程经验

1.    在头文件中声明全局变量，如果对其初始化，则相当于定义该变量，包含此头文件的源文件如果是多个，则会出现重复定义错误。
2.    多个条件同时满足要判断其中一个不满足时候的超时条件，例如过流后失压保护的过流和失压两个条件，备自投的对侧跳闸和失压两个条件。
3.    一个功能，无非就是启动条件，动作条件，超时条件，结束条件；
4.    哪些条件是循环检测的，哪些条件是检测一次的。
5.    哪些标志是不断置位的，哪些标志是置位一次的。
6.    对于main.c文件中，main函数中的主while循环，它应该尽可能快的一遍一遍的循环，因此一般设置为100ms或200ms执行一次住循环；
7.    主循环的作用是先调用一些功能函数，再收发消息，即，执行完一遍功能函数，保证收发一次消息，再进行下一遍；
8.    消息处理和功能函数是分开的，保证消息及时更新，并且程序结构清晰；
9.    一般不会在功能函数中使用很长的延时，导致功能函数长期占用，使得消息不能及时更新；
10.    一般不会在功能函数中处理消息，导致结构不清晰，使得你这次调用的功能函数读取的不知道是哪次的消息；
11.    功能函数不论是进入了对应的线程还是怎样，住循环都是要保证大概100ms或200ms一遍一遍循环；
12.    零序越限告警的数据来源用实际零序，不能用合成零序
13.    人工置数对应数据表，但合成值不能置数
14.    人工置数数值当作有效值，要幅值应乘以根号2
15.    开发平台用的是ANSI编码，会提示一个奇怪的字符stray in program
16.    Api.c中API函数ShmRecProcess会引用Api_Rec_MSG_Process函数，因此每个进程都要调用后者，否则会报undefined reference to 错误；ApiProcess函数会调用后者。
17.    突变量必需用实际零序
18.    “直控SBO之间需预留几毫秒的时间,否则会冲突”指的是：当多条线路需要跳闸时，他们之间需要的时间间隔。
19.    接收到手合消息就相当于知道了开关合位。而不是直接检测到开关位置，检测开关位置应该不是ai进程干的事情。
失压保护
20.    失压后置位失压故障标志，保护跳闸后，只要故障不消失（保持失压状态），失压保护任务函数就不会退出，重新上电后，失压保护才能返回。然后重新检测失压前有压。
21.    过流后置位过流故障标志，保护跳闸后，过流故障即会消失，保护跟着就能返回。
22.    对于过流保护，故障状态和返回状态是过流和无流，因此保护动作后即能够返回；
23.    对于失压保护，故障状态和返回状态都是无压，因此保护动作后和故障状态是一样的，返回时机是重新上电时。
过流后失压
24.    过流启动，检测到无压无流，开始计时（例如保护延时设置为5s），如果无压无流计时5s到后，准备跳闸出口，结果不满足无压无流条件了，此时动作出口条件不满足，是不是该返回？    不该返回！因为如果电流存在抖动，则会不断的重新启动保护。这种情况就当作不满足无压无流条件，未动作，20s超时返回，就结束了。然后过流消失后，清掉超时标志，一切就从头开始了。
备自投
25.    控制字在BZT.C文件中都是判0返回。
26.    软压板在BZT.C文件中都是判0返回。
27.    闭锁条件是在检测函数（调用启动函数）要判断、在任务函数要判断，因为他们属于不同的线程（即不是顺序执行，需要分别判断，有可能检测时不满足闭锁条件，任务时满足闭锁条件不能动作了）。
28.    闭锁条件在收到遥信变位消息时闭锁，在满足解锁条件且已闭锁时解锁。
29.    闭锁是在某一刻发生的，解锁是在循环检测的。
30.    区分主备供设备的软件中，要设置一个备自投激活标志BztEnable。
31.    各种合闸标志是延时自动清除的，其他标志例如手分、遥分不是。
线路备自投
32.    控制字和软压板在start_up函数中判断。
33.    失压前有压标志：JXBZTLostVDectect
34.    对侧跳闸标志：BZT_ChangeFlag
a)    收到对侧跳闸遥信变位时置0xff；
b)    判0xff，满足备自投启动条件，则调用start_up函数后，清0；
c)    注意此遥信发生变位后，除非启动，并不延时自动清除
35.    解锁条件（解锁是为了在恢复初始状态下，保护也恢复初始状态）：
a)    母联备自投：本母联开关分位，两侧合位且有压；
b)    线路备自投：本进线开关分位，对侧合位且有压；
36.    母联备自投返回是因为不再需要母联合闸供电，两侧均有压则跳闸让他们各自供电，两侧均无压则母联合着也没有用处，也返回，母联返回后，母联开关跳开，若两侧有压，则解锁母联备自投。
37.    线路备自投不需要返回是因为必定是两个进线之一供电。
张供备自投
38.    何时检测电压？只要开关分位就循环检测是否有压。
39.    有压标志的置位和清除？跳闸清除（返回条件），和上一题是配合的；重合闸清除（动作条件）；超时清除（超时条件）
人工置数
40.    人工置数作用于（修改）各交流通道的基波值；
41.    程序改进：人工置数功率的时候，power.c中不应该再计算功率，而是应该采用人工置数的功率，因此在计算功率的位置加上未进行人工置数的判断条件。（ai56V501）
42.    人工置数操作的是二次值
永久故障虚遥信
43.    重合闸投入：
重合成功则为瞬时性故障，置瞬时故障虚遥信（在一定时间内检测到不过流）；
重合失败则为永久性故障，置永久故障虚遥信（即重合到故障，重合后、加速跳前检测到过流）；
重合闸后才能判是永久故障还是瞬时故障：
后加速延时前(重合闸后，后加速延时未到这段时间）
如果过流，则为永久性故障；
如果有流但不过流，则为瞬时性故障；
如果无流，那么则可能是因为重合后，电流还没上来，一直无流则超时返回
    后加速延时后
        如果跳闸
肯定无流，肯定为永久性故障，
无流前肯定有流，所以在此前已经能判断出来。
        如果没跳
            肯定有流且不过流，肯定为瞬时性故障
            同样在此前已经能判断
44.    重合闸退出：
过流告警后有压则为永久性故障，置永久故障虚遥信；
过流告警后，延时后检测到无压（说明上游开关跳闸了）则为瞬时性故障，置瞬时故障虚遥信；
故障检测
45.    相间故障持续时间 duration：
a)    越限启动时刻，开始计 duration， 如果发现此前有突变量启动（从不过流到过流突变），则实际故障在越限启动前就开始了，所以计的晚了，要加上这段补偿时间；
b)    越限结束时刻，结束计 duration， 如果发现此前有突变量启动（从过流到不过流突变），则实际故障在越限结束前就结束了，所以计的晚了，要减去这段补偿时间。
故障复归
46.    由于线路灯是两种故障检测功能复用的，所以熄灭时，需要注意：
a)    相间故障消失，需熄灭线路灯，前提是接地故障消失；
b)    接地故障消失，需熄灭线路灯，前提是相间故障消失；
47.    自动复归、手动复归、主站复归
分相故障虚遥信
48.    虚遥信置位的时候，是先上报总故障，再上报分相故障（因为总故障了，才判断具体哪一项故障）；
49.    虚遥信清除的时候，是先清除分相故障，再清除总故障（因为只有每一相故障都消失了，该线路故障才算消失了）。
高端保存
50.    接收并存储：SOE消息，SBO消息，DO消息。
51.    数据表中都不是本地数据
52.    模拟量进程发本地的SOE消息，转换成高端进程关联的数据进行存储。
53.

1.    使某段代码只能执行一次的标志：
a)    跳闸/告警标志TripMask[_Max_IGroups]：
i.    类型：公共变量；
ii.    作用：保证跳闸/告警只执行一次；
iii.    应用：存在于每个保护功能的检测函数和任务函数中；
iv.    说明：每条线路设置一个标志，跳闸是对于线路来讲的，一条线路对应多个保护，一条线路的多个保护用故障位指示的位掩码区分，使一条线路的各个保护互不影响，只保证当前保护只跳闸一次，即一条线路的多个保护要跳闸则都会跳，不过最后还是要取决于SBOTripMask；
v.    操作：
1.    各保护检测函数中，保护未使能时，清0，表示未跳闸状态，反向思维，试想，如果在标志为1的时候，该保护由使能变成未使能，并且这里没有给标志清0，会导致重新使能的时刻假如刚好线路正在过流，则不能跳闸了，另外也相当于一个保护投入前的初始化；
2.    各保护任务函数中，过流切除后，清0，标志本次保护结束了，又可以跳闸了；
3.    保护任务函数中，过流依旧存在，则判0置1，保证跳闸/告警一次；
2.    延时：
a)    进程延时Tdelay：
i.    应用1：保护任务函数循环执行时，在存在故障大循环末尾，在线路循环外的位置，延时是为了等待采样数据，因为采样的周期是20ms，检测的太快，采样数据还没来得及更新，是没有意义的；
ii.    应用2：如果不是首次跳闸，则需要设置一个跳闸时间间隔，直控SBO之间需预留几毫秒的时间,否则会冲突.；
b)    保护延时duration：
i.    Start：一般在检测函数中，检测到过流的时刻，并写入保护信息；
ii.    Stop：一般在任务函数中，取当前时间，每次进入函数时判断延时是否到；
3.    跳/合闸接点返回状态（Trip_Struct结构体类型）：
a)    跳闸接点返回状态trip_reply：在需要跳闸的地方判-1赋0；
b)    合闸接点返回状态close_reply：在需要合闸的地方判-1赋0；
4.    SBOTripMask标志：
a)    说明：SBO跳闸接点需要释放的线路标志；
b)    应用：不同的保护所有线路（位掩码）都用同一个跳闸标志，因为一条线路不同保护控的是同一个开关；
5.    配置文件：
a)    配置文件中的数字都属于字符串；
6.    各函数执行的循环周期：
a)    采样数据更新：        只要有未处理的数据窗则执行；
b)    Fundamental函数：    每个数据窗执行一次；
c)    prot_dect函数：        每个数据窗执行一次；
d)    各保护线程：        1ms执行一次，相当于不断循环执行；
7.    通道号问题：
a)    通道与硬件采样是对应的，因此必须是从0开始往下排列，顶多通道不使能，采上来的数据不用，但只是软件不用，硬件依旧要采；
b)    通道关联的线路号是随意配置的，可以不按顺序，也可以空出几个号。因此最大线路数看的是配置的最大的通道号是几，有可能按通道轮询时，线路号号先是3，后是1，有可能最大配了12，实际上只有8路；
c)    通道的使能会影响线路的使能；
d)    计算某个通道的某些值时，首先要判断这个通道是否有效；
i.    RMS值：
ii.    校正：
iii.    突变量检测：
e)    计算某条线路的某些值时，首先要判断这条线路是否有效，否则返回默认值；
i.    最大电流/电压：如果这条线路未使能则返回默认值0；
ii.    最小电流/电压：如果这条线路未使能则返回默认值32767；
iii.    最大零序电流/电压：    有实际通道则返回实际通道值，星形连接则返回合成值，否则（不存在这条线路的零序）返回0；
f)    保护功能是不管实际的线路存在与否的，它只认自己的保护配置，按照线路轮询的时候，如果某条线路不存在，则会取上面的默认值，保护也是执行不下去的；
8.    采样通道顺序问题：
a)    实际采样通道顺序（先直流后交流）只影响s_buf数组的偏移量，用户方式字中的通道顺序（先交流后直流）影响数据处理时偏移量，和实际通道的采样顺序是两码事；
9.    系统变量:
a)    HaveMsg
10.    头文件定义一个变量，然后在各个源文件包含时，相当于每个源文件都进行一次定义，导致重复定义错误，如果声明为static，把变量的作用域限制在当前文件，则相当于每个文件都定义了一个限制在本文件的变量，这些变量名字相同，但却是不同的变量，正确的用法是在某个源文件中定义变量，在头文件中用extern声明，则想当于包含这个头文件的每个源文件都对那个源文件定义的变量进行声明，得以正确使用。但是数组就可以定义在头文件，然后各个源文件包含？

# 标志类变量的使用

保护、故障存在掩码标志 (overI1Mask)

检测函数中，保护的启动条件
任务函数中，只要故障未消失，则会一直循环检测
一般而言，保护延时到，成功跳闸，过流就会消失，标志就可以清除

不能在检测函数中清除。

a)    如果故障持续不消失（长于过流后失压保护延时），Mask标志无法清除，则任务函数中的循环无法退出（不断延时和轮询），任务函数无法返回，此时，故障结束，在检测函数中将标志清除（错误的处理方法），此时任务函数没有返回，但是while循环无法进入（在检测函数中清除标志相当于在主线程中清除标志，而主线程是10ms执行一次的，执行主线程可能只占10ms外的1ms，任务函数所在线程是5ms执行一次的，执行任务函数可能只占5ms外的0.5ms，主线程在清标志的那一刻，任务函数线程很可能在等待期，也就是while循环之外，因此导致while循环无法进入），退到外层的while(1)，然后等待激活信号（其实也相当于返回了，只不过不是正常的返回，因为这次返回是外部（主线程）导致的，强制任务函数执行完毕，没有清first标志，正常任务函数内部清标志会同时清first标志，等待下次激活，具体看下一段）。
b)    然后再次过流故障，由于上一次任务函数并未能在任务函数中清除Mask标志（Mask标志是first标志清除的使能条件），导致first标志未能清除，因此这次故障无法激活任务函数。

2.    激活一次任务标志的作用是不论所有线路中检测到多少故障，只激活一次任务函数（一个任务函数就能够处理所有故障）如果此次任务函数未能返回，则无法再次激活任务函数
3.    跳闸反馈标志 trip_reply
a)    作为分合闸操作函数返回值的作用是操作跳闸开始成功则保持标志为0，如果操作跳闸开始失败则跳闸再次使能，可以再次尝试跳闸，即不再是首次跳闸了
b)    跳闸任务函数中判断为0的作用是调用操作跳闸开始函数成功，才能在延时后继续调用操作跳闸结束函数，如果开始函数没有成功，则如第3条所说的继续调用开始函数。而结束函数不论成功与否，都本次动作都结束了。
c)    跳闸结束后置为-1作用是保证本次跳闸脉冲完成后才使能下一次跳闸
4.    TripMask是与线路和保护关联的，不同的线路不同的保护都要区分；
5.    trip_reply是与线路开关关联的，多个保护跳闸可能同时作用于同一个开关，都希望开关跳闸，则此标志可使开关只跳一次，它对开关负责，而不是对保护负责。
6.   CloseMask[line] & BitMask[_FDLLBZT_StageBit]) == 0)
因为是任务函数是在while循环里的，而不是各线路循环一次就完事。所以要判，

# 经验

1. Mac 地址相同时, 会导致通信中断

# 测试技巧

1.    正向，反向功率两种过流保护，定值分别设置为一个大值，一个小值，测试源加一个中间值，例如定值设为3A和5A，测试源加4A，则5A的跳闸，3A的不应该跳闸；
2.    多路同时跳闸，把SBO脉冲接到遥信上，遥信SOE变位即脉冲保持时间，可查看是否会出现100ms的脉冲是否会影响500ms的脉冲；
3.

# 工作经验

一、    程序经验：
1.    扫描间隔：主调函数不断调用被调函数，问他数据准备好了没，或者标志置位能向下执行了没，或者延时时间到了没；
2.    循环间隔：任务函数不断循环执行，每次循环更新判断条件，或者延时时间，看是否向下执行。程序是不断循环执行的，例如一个故障过程中，函数循环执行很多遍，延时的判断，这次执行是1ms，下次执行到这里是2ms，5ms才往下继续执行，注意不同情况下，函数走向的不同；
3.    硬件资源占用：编程要考虑CPU占用率，内存等因素；
4.    数据接口：用户方式字、工厂方式字、驱动程序等等；
5.    录波时，频率高的波形采样频率高，采样点多，频率低的时候反之，这是基本思路；
6.    哪些故障会使波形频率变快？

二、    学习经验：
1.    看程序不要想当然，想想为什么这样，不这样的话会有什么问题；
2.    看程序想象电脑刷刷刷一遍遍执行下来的样子；
3.    想要看功能是如何实现的，就要怀疑每一条语句为什么出现在它所在的位置，不能想当然；
4.    看完在脑中回炉，想想自己能不能有思路写程序；
5.    看一点，记住一点。
