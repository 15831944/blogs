# 任务管理 Task Management

小型多任务嵌入式系统

1. 软实时: 计算机对每一个输入的响应应当限定在一个恰当的时间范围
2. 硬实时: 任务必须在给定的时间限制内完成

任务

1. 任务: 每个执行线程都被称为任务
2. 任务函数: 函数原型规定为返回void 函数参数为void*, 实现为死循环, 不可以return, 应调用vTaskDelete删除一个任务
3. 任务实例: 创建任务时产生任务实例, 一个任务函数可对应多个任务实例, 任务函数相同的任务实例之间是独立运行的
4. 也可以在一个任务函数1中(死循环前)创建另一个任务2, 效果和分别创建相同, 但是会先启动调度器执行任务1, 再在任务1中创建并执行任务2

调度器

1. 调度器: 能够让任务切入切出(switched in out)的唯一实体, 总是在所有就绪态任务中选择具有最高优先级的任务，并使其进入运行态。
2. 时间片: 心跳中断的频率的倒数, 任务切换的时间间隔
3. 时钟心跳(时钟滴答, tick): 调度器的时钟, 内核或这说调度器运行在心跳中断中
4. 心跳中断(tick interrupt): 调度器在一个任务的时间片结束时通过心跳中断运行调度器(操作系统内核)自身, 调度器运行在心跳中断中, 心跳中断开始和完成即一个时间片的开始和结束
5. 心跳计数(tick count): 从调度器启动开始, 心跳中断总数

任务优先级

1. 任务优先级: 任意数量的任务共享同一个优先级
2. 饿死(starved): 如果高优先级的任务一直处于运行状态(不进入阻塞状态), 由于调度器总会选择高优先级任务, 低优先级任务的执行时间会被高优先级任务饿死
3. 事件驱动任务: 高优先级任务由事件驱动, 没有事件发生则不能运行, 则调度器会选择优先级次之的能够进入运行状态的任务, 避免低优先级任务被饿死

任务类型

1. 持续处理任务(continuous processing task): 要么一直运行, 要么就绪, 无阻塞, 不等待事件
2. 周期任务(Periodic task): 可以阻塞, 等待定时事件

事件驱动

1. 定时事件: 延迟到期或是绝对时间到点. 超时或周期性行为, 调用延时函数进入阻塞状态, 延时到后进入就绪状态
2. 同步事件: 源于其它任务或中断的事件. 队列, 二值信号量, 计数信号量, 互斥(递归)信号量, 互斥量, 都可以实现同步事件, 等待超时则退出阻塞状态

任务状态

1. 运行状态（running)
2. 阻塞状态(blocked): 任务正在等待定时事件或同步事件的发生
3. 挂起状态(suspended): 对调度器不可见
4. 就绪状态(ready):

1. 阻塞是针对任务而言的, 任务调用一个会阻塞的函数导致的是调用任务被阻塞在这个函数而不是函数被阻塞
4. 顶层任务状态: 运行状态, 非运行状态(休眠)
5. 任务状态转移: 非运行状态到运行状态为切入(switched in), 反之为切出(switched out)

空闲任务

1. 空闲任务: 拥有最低优先级0, 保证高优先级的任务可以抢占空闲任务以得到执行
2. 空闲任务钩子函数(或称回调，hook, or call-back)，可以直接在空闲任务中添加应用程序相关的功能。空闲任务钩子函数会被空闲任务每循环一次就自动调用一次。
3. 空闲任务的任务实现不只包括钩子函数, 还包括任务的内核资源回收, 前者尽快返回, 后者才能工作, 钩子函数不能阻塞或挂起, 因为会导致处理器无代码可执行?

1. 执行低优先级，后台或需要不停处理的功能代码。
2. 测试系统处理裕量(空闲任务只会在所有其它任务都不运行时才有机会执行，所以测量出空闲任务占用的处理时间就可以清楚的知道系统有多少富余的处理时间)。
3. 将处理器配置到低功耗模式——提供一种自动省电方法，使得在没有任何应用功能需要处理的时候，系统自动进入省电模式。

调度算法

1. 抢占式调度(固定优先级): 高优先级在时间片结束时抢占(pre_empted)运行状态的低优先级任务, 优先级由任务手动进行修改, 而不能由内核修改
2. 协作式调度: 采用一个纯粹的协作式调度器，只可能在运行态任务进入阻塞态或是运行态任务显式调用taskYIELD()时，才会进行上下文切换。
3. 混合调度: 需要在中断服务例程中显式地进行上下文切换，从而允许同步事件产生抢占行为，但时间事件却不行。这样做的结果是得到了一个没有时间片机制的抢占式系统。

1. 单调速率调度(Rate Monotonic Scheduling, RMS)是一种常用的优先级分配技术。其根据任务周期性执行的速率来分配一个唯一的优先级。具有最高周期执行频率的任务赋予高最优先级；具有最低周期执行频率的任务赋予最低优先级。这种优先级分配方式被证明了可以最大化整个应用程序的可调度性(schedulability)

API 函数

```
// 字母 x 表示可移植的基本数据类型
portBASE_TYPE			xTaskCreate();				// 创建任务, 分别传入任务函数名和函数参数, 栈空间(字) = 栈宽度 * 栈深度
vTaskStartScheduler();		// 启动调度器开始执行已创建的任务以及空闲任务, 然后 main 函数就不执行了?休眠了?
vTaskSuspend();				// 将任务挂起
vTaskResume();				// 唤醒挂起的任务
vTaskResumeFromISR();		// 唤醒挂起的任务
void					vTaskPrioritySet();			// 在任务启动后修改任务优先级
unsigned portBASE_TYPE	uxTaskPriorityGet();		// 查询任务优先级
void					vTaskDelay();				// 等待定时事件, 相对时间, 使任调用务进入阻塞状态, 经过参数指定的心跳周期数后, 进入就绪状态
void					vTaskDelayUntil();			// 等待定时事件, 绝对时刻, 使调用任务进入阻塞状态, 在绝对时刻并以固定频率, 进入就绪状态
void					vTaskDelete();				// 删除指定任务, 参数为 NULL 则删除当前任务
void					aTaskFunction(void *pvParameters);	// 任务函数的函数原型
void					vApplicationIdleHook(void);			// 钩子函数的函数原型
```
