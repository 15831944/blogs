# 软件需要采集的模拟量数据的类型

RMS                      均方根值         电流电压有效值 root meam square
True Power            有效功率
Apparent Power      视在功率
Complex Power      复数功率
Power Factor          功率因数
Phase Angle            相位角
Neutral Current       中性线电流
Temperature DC
Future DC
Real energy
Reactive Energy      无功电能

# 编程经验

永久故障虚遥信
43.    重合闸投入：
重合成功则为瞬时性故障，置瞬时故障虚遥信（在一定时间内检测到不过流）；
重合失败则为永久性故障，置永久故障虚遥信（即重合到故障，重合后、加速跳前检测到过流）；
重合闸后才能判是永久故障还是瞬时故障：
后加速延时前(重合闸后，后加速延时未到这段时间）
如果过流，则为永久性故障；
如果有流但不过流，则为瞬时性故障；
如果无流，那么则可能是因为重合后，电流还没上来，一直无流则超时返回
    后加速延时后
        如果跳闸
肯定无流，肯定为永久性故障，
无流前肯定有流，所以在此前已经能判断出来。
        如果没跳
            肯定有流且不过流，肯定为瞬时性故障
            同样在此前已经能判断
44.    重合闸退出：
过流告警后有压则为永久性故障，置永久故障虚遥信；
过流告警后，延时后检测到无压（说明上游开关跳闸了）则为瞬时性故障，置瞬时故障虚遥信；
故障检测
45.    相间故障持续时间 duration：
a)    越限启动时刻，开始计 duration， 如果发现此前有突变量启动（从不过流到过流突变），则实际故障在越限启动前就开始了，所以计的晚了，要加上这段补偿时间；
b)    越限结束时刻，结束计 duration， 如果发现此前有突变量启动（从过流到不过流突变），则实际故障在越限结束前就结束了，所以计的晚了，要减去这段补偿时间。
故障复归
46.    由于线路灯是两种故障检测功能复用的，所以熄灭时，需要注意：
a)    相间故障消失，需熄灭线路灯，前提是接地故障消失；
b)    接地故障消失，需熄灭线路灯，前提是相间故障消失；
47.    自动复归、手动复归、主站复归
分相故障虚遥信
48.    虚遥信置位的时候，是先上报总故障，再上报分相故障（因为总故障了，才判断具体哪一项故障）；
49.    虚遥信清除的时候，是先清除分相故障，再清除总故障（因为只有每一相故障都消失了，该线路故障才算消失了）。
高端保存
50.    接收并存储：SOE消息，SBO消息，DO消息。
51.    数据表中都不是本地数据
52.    模拟量进程发本地的SOE消息，转换成高端进程关联的数据进行存储。
53.

1.    使某段代码只能执行一次的标志：
a)    跳闸/告警标志TripMask[_Max_IGroups]：
i.    类型：公共变量；
ii.    作用：保证跳闸/告警只执行一次；
iii.    应用：存在于每个保护功能的检测函数和任务函数中；
iv.    说明：每条线路设置一个标志，跳闸是对于线路来讲的，一条线路对应多个保护，一条线路的多个保护用故障位指示的位掩码区分，使一条线路的各个保护互不影响，只保证当前保护只跳闸一次，即一条线路的多个保护要跳闸则都会跳，不过最后还是要取决于SBOTripMask；
v.    操作：
1.    各保护检测函数中，保护未使能时，清0，表示未跳闸状态，反向思维，试想，如果在标志为1的时候，该保护由使能变成未使能，并且这里没有给标志清0，会导致重新使能的时刻假如刚好线路正在过流，则不能跳闸了，另外也相当于一个保护投入前的初始化；
2.    各保护任务函数中，过流切除后，清0，标志本次保护结束了，又可以跳闸了；
3.    保护任务函数中，过流依旧存在，则判0置1，保证跳闸/告警一次；
2.    延时：
a)    进程延时Tdelay：
i.    应用1：保护任务函数循环执行时，在存在故障大循环末尾，在线路循环外的位置，延时是为了等待采样数据，因为采样的周期是20ms，检测的太快，采样数据还没来得及更新，是没有意义的；
ii.    应用2：如果不是首次跳闸，则需要设置一个跳闸时间间隔，直控SBO之间需预留几毫秒的时间,否则会冲突.；
b)    保护延时duration：
i.    Start：一般在检测函数中，检测到过流的时刻，并写入保护信息；
ii.    Stop：一般在任务函数中，取当前时间，每次进入函数时判断延时是否到；
3.    跳/合闸接点返回状态（Trip_Struct结构体类型）：
a)    跳闸接点返回状态trip_reply：在需要跳闸的地方判-1赋0；
b)    合闸接点返回状态close_reply：在需要合闸的地方判-1赋0；
4.    SBOTripMask标志：
a)    说明：SBO跳闸接点需要释放的线路标志；
b)    应用：不同的保护所有线路（位掩码）都用同一个跳闸标志，因为一条线路不同保护控的是同一个开关；
5.    配置文件：
a)    配置文件中的数字都属于字符串；
6.    各函数执行的循环周期：
a)    采样数据更新：        只要有未处理的数据窗则执行；
b)    Fundamental函数：    每个数据窗执行一次；
c)    prot_dect函数：        每个数据窗执行一次；
d)    各保护线程：        1ms执行一次，相当于不断循环执行；
7.    通道号问题：
a)    通道与硬件采样是对应的，因此必须是从0开始往下排列，顶多通道不使能，采上来的数据不用，但只是软件不用，硬件依旧要采；
b)    通道关联的线路号是随意配置的，可以不按顺序，也可以空出几个号。因此最大线路数看的是配置的最大的通道号是几，有可能按通道轮询时，线路号号先是3，后是1，有可能最大配了12，实际上只有8路；
c)    通道的使能会影响线路的使能；
d)    计算某个通道的某些值时，首先要判断这个通道是否有效；
i.    RMS值：
ii.    校正：
iii.    突变量检测：
e)    计算某条线路的某些值时，首先要判断这条线路是否有效，否则返回默认值；
i.    最大电流/电压：如果这条线路未使能则返回默认值0；
ii.    最小电流/电压：如果这条线路未使能则返回默认值32767；
iii.    最大零序电流/电压：    有实际通道则返回实际通道值，星形连接则返回合成值，否则（不存在这条线路的零序）返回0；
f)    保护功能是不管实际的线路存在与否的，它只认自己的保护配置，按照线路轮询的时候，如果某条线路不存在，则会取上面的默认值，保护也是执行不下去的；
8.    采样通道顺序问题：
a)    实际采样通道顺序（先直流后交流）只影响s_buf数组的偏移量，用户方式字中的通道顺序（先交流后直流）影响数据处理时偏移量，和实际通道的采样顺序是两码事；
9.    系统变量:
a)    HaveMsg
10.    头文件定义一个变量，然后在各个源文件包含时，相当于每个源文件都进行一次定义，导致重复定义错误，如果声明为static，把变量的作用域限制在当前文件，则相当于每个文件都定义了一个限制在本文件的变量，这些变量名字相同，但却是不同的变量，正确的用法是在某个源文件中定义变量，在头文件中用extern声明，则想当于包含这个头文件的每个源文件都对那个源文件定义的变量进行声明，得以正确使用。但是数组就可以定义在头文件，然后各个源文件包含？

# 标志类变量的使用

保护、故障存在掩码标志 (overI1Mask)

检测函数中，保护的启动条件
任务函数中，只要故障未消失，则会一直循环检测
一般而言，保护延时到，成功跳闸，过流就会消失，标志就可以清除

不能在检测函数中清除。

a)    如果故障持续不消失（长于过流后失压保护延时），Mask标志无法清除，则任务函数中的循环无法退出（不断延时和轮询），任务函数无法返回，此时，故障结束，在检测函数中将标志清除（错误的处理方法），此时任务函数没有返回，但是while循环无法进入（在检测函数中清除标志相当于在主线程中清除标志，而主线程是10ms执行一次的，执行主线程可能只占10ms外的1ms，任务函数所在线程是5ms执行一次的，执行任务函数可能只占5ms外的0.5ms，主线程在清标志的那一刻，任务函数线程很可能在等待期，也就是while循环之外，因此导致while循环无法进入），退到外层的while(1)，然后等待激活信号（其实也相当于返回了，只不过不是正常的返回，因为这次返回是外部（主线程）导致的，强制任务函数执行完毕，没有清first标志，正常任务函数内部清标志会同时清first标志，等待下次激活，具体看下一段）。
b)    然后再次过流故障，由于上一次任务函数并未能在任务函数中清除Mask标志（Mask标志是first标志清除的使能条件），导致first标志未能清除，因此这次故障无法激活任务函数。

2.    激活一次任务标志的作用是不论所有线路中检测到多少故障，只激活一次任务函数（一个任务函数就能够处理所有故障）如果此次任务函数未能返回，则无法再次激活任务函数
3.    跳闸反馈标志 trip_reply
a)    作为分合闸操作函数返回值的作用是操作跳闸开始成功则保持标志为0，如果操作跳闸开始失败则跳闸再次使能，可以再次尝试跳闸，即不再是首次跳闸了
b)    跳闸任务函数中判断为0的作用是调用操作跳闸开始函数成功，才能在延时后继续调用操作跳闸结束函数，如果开始函数没有成功，则如第3条所说的继续调用开始函数。而结束函数不论成功与否，都本次动作都结束了。
c)    跳闸结束后置为-1作用是保证本次跳闸脉冲完成后才使能下一次跳闸
4.    TripMask是与线路和保护关联的，不同的线路不同的保护都要区分；
5.    trip_reply是与线路开关关联的，多个保护跳闸可能同时作用于同一个开关，都希望开关跳闸，则此标志可使开关只跳一次，它对开关负责，而不是对保护负责。
6.   CloseMask[line] & BitMask[_FDLLBZT_StageBit]) == 0)
因为是任务函数是在while循环里的，而不是各线路循环一次就完事。所以要判，

# 经验

1. Mac 地址相同时, 会导致通信中断

# 测试技巧

1.    正向，反向功率两种过流保护，定值分别设置为一个大值，一个小值，测试源加一个中间值，例如定值设为3A和5A，测试源加4A，则5A的跳闸，3A的不应该跳闸；
2.    多路同时跳闸，把SBO脉冲接到遥信上，遥信SOE变位即脉冲保持时间，可查看是否会出现100ms的脉冲是否会影响500ms的脉冲；
3.

# 工作经验

一、    程序经验：
1.    扫描间隔：主调函数不断调用被调函数，问他数据准备好了没，或者标志置位能向下执行了没，或者延时时间到了没；
2.    循环间隔：任务函数不断循环执行，每次循环更新判断条件，或者延时时间，看是否向下执行。程序是不断循环执行的，例如一个故障过程中，函数循环执行很多遍，延时的判断，这次执行是1ms，下次执行到这里是2ms，5ms才往下继续执行，注意不同情况下，函数走向的不同；
3.    硬件资源占用：编程要考虑CPU占用率，内存等因素；
4.    数据接口：用户方式字、工厂方式字、驱动程序等等；
5.    录波时，频率高的波形采样频率高，采样点多，频率低的时候反之，这是基本思路；
6.    哪些故障会使波形频率变快？

二、    学习经验：
1.    看程序不要想当然，想想为什么这样，不这样的话会有什么问题；
2.    看程序想象电脑刷刷刷一遍遍执行下来的样子；
3.    想要看功能是如何实现的，就要怀疑每一条语句为什么出现在它所在的位置，不能想当然；
4.    看完在脑中回炉，想想自己能不能有思路写程序；
5.    看一点，记住一点。
