# 线程模型的发展

1. LinuxThreads: LinuxThreads有些方面受限于内核的特性，从而违背了SUSV3 Pthreads标准。即它要根据内核的特性来实现线程，有些地方没有遵循统一的标准。
2. NGPT: 后来IBM开发了NGPT(Next Generation POSIX Threads)，性能明显优于LinuxThreads，人们曾把它当作LinuxThreads的继任者。
3. NPTL: 但最后，又有一个项目NPTL(Native POSIX Threads Library)出来后，性能更优于NGPT。2002年NGPT项目停止开发，我们现在用的Linux线程就是NPTL。

# 线程模型的实现

1. x对y(x:y)的含义: x个用户线程, y个内核调度实体(Kernel Scheduling Entity，是内核分配CPU的对象单位)
2. LinuxThreads 和 NPTL 都是采用一对一的线程模型，NGPT 采用的是多对多的线程模型

# 多对一(M:1)的用户级线程模型

多对一线程模型中，线程的创建、调度、同步的所有细节全部由进程的用户空间线程库来处理。用户态线程的很多操作对内核来说都是透明的，因为不需要内核来接管，这意味不需要内核态和用户态频繁切换。线程的创建、调度、同步处理速度非常快。当然线程的一些其他操作还是要经过内核，如IO读写。这样导致了一个问题：当多线程并发执行时，如果其中一个线程执行IO操作时，内核接管这个操作，如果IO阻塞，用户态的其他线程都会被阻塞，因为这些线程都对应同一个内核调度实体。在多处理器机器上，内核不知道用户态有这些线程，无法把它们调度到其他处理器，也无法通过优先级来调度。这对线程的使用是没有意义的

# 一对一(1:1)的内核级线程模型

一对一模型中，每个用户线程都对应各自的内核调度实体。内核会对每个线程进行调度，可以调度到其他处理器上面。当然由内核来调度的结果就是：线程的每次操作会在用户态和内核态切换。另外，内核为每个线程都映射调度实体，如果系统出现大量线程，会对系统性能有影响。但该模型的实用性还是高于多对一的线程模型。

# 多对多(M:N)的两级线程模型

每个线程可以拥有多个调度实体，也可以多个线程对应一个调度实体。听起来好像非常完美，但线程的调度需要由内核态和用户态一起来实现。可想而知，多个对象操作一个东西时，肯定要一些其他的同步机制。用户态和内核态的分工合作导致实现该模型非常复杂。NPTL曾经也想使用该模型，但它太复杂，要对内核进行大范围改动，所以还是采用了一对一的模型。

# 线程属性变量

# 线程作用域

PTHREAD_PROCESS_SHARE		多进程可见
PTHREAD_PROCESS_PRIVATE		仅支持单进程

# 线程堆栈大小

pthread_attr_setstacksize(&thrd_attr_p, 16*1024);	// 16MB
