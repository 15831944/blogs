# 线程同步机制

线程同步机制包括: 互斥量, 读写锁, 条件变量, 自旋锁, 屏障

# 互斥量

# 互斥量在内核中的定义

```
struct mutex
{
    /* 1: unlocked, 0: locked, negative: locked, possible waiters */
    atomic_t			count;
    spinlock_t			wait_lock;
    struct list_head	wait_list;

#if defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_SMP)
    struct task_struct *owner;
#endif

#ifdef CONFIG_DEBUG_MUTEXES
    const char *name;
    void *magic;
#endif

#ifdef CONFIG_DEBUG_LOCK_ALLOC
    struct lockdep_map	dep_map;
#endif

};
```

```
struct mutex {
	/* 1: unlocked, 0: locked, negative: locked, possible waiters */
	atomic_t			count;
	spinlock_t			wait_lock;
	struct list_head	wait_list;
	struct task_struct	*owner;
};
```

# 互斥量的作用

同一时刻，只允许一个线程对临界区进行访问. 多个临界区之间是互斥的，即只能一个执行完了再执行下一个, 临界区是指加锁和解锁之间的那段代码

例如，线程1的代码块A(如条件变量信号)和线程2的代码块B(如条件变量等待)都使用同一个互斥量加锁和解锁。内核先调度线程1，线程1对互斥量并执行代码块A。此时如果线程2被调度执行代码块B，由于互斥量已经被锁，因此线程2会阻塞在代码块B起始处。直到线程1执行完代码块A并解锁后，线程2才能执行代码块B。最终导致代码块A和代码块B的执行是互斥的。即一个执行期间，另一个不能执行。临界区内的操作近似为原子操作。

互斥锁的主要特点是互斥锁的释放必须由上锁的进(线)程释放，如果拥有锁的进(线)程不释放，那么其它的进(线)程永远也没有机会获得所需要的互斥锁。

# 互斥量的原理

互斥锁的实现原理是使进程休眠, 在实现中，锁并不是与某个具体的变量进行关联，它本身是一个独立的对象。进(线)程在有需要的时候获得此对象，用完不需要时就释放掉。

# 互斥量类型属性变量

Linux

| macro                    | meaning               |
| ------------------------ | --------------------- |
| PTHREAD_MUTEX_NORMAL     | 默认属性                |
| PTHREAD_MUTEX_ERRORCHECK | 会进行错误检查，速度比较慢 |
| PTHREAD_MUTEX_RECURSIVE  | 递归锁, 同一个线程对一个递归锁加锁多次，会有一个锁计数器，解锁的时候也需要解锁这个次数才能释放该互斥量 |

uclinux

| macro                       | meaning |
| --------------------------- | ------- |
| PTHREAD_MUTEX_TIMED_NP      | 普通锁   |
| PTHREAD_MUTEX_ADAPTIVE_NP   | 适应锁   |
| PTHREAD_MUTEX_RECURSIVE_NP  | 嵌套锁   |
| PTHREAD_MUTEX_ERRORCHECK_NP | 检错锁   |

# 互斥量共享属性变量

| macro                       | meaning               |
| --------------------------- | --------------------- |
| PTHREAD_PROCESS_SHARE       | 进程间锁：进程间同步      |
| PTHREAD_PROCESS_PRIVATE     | 进程内锁：进程内线程间同步 |

# 互斥量的死锁

死锁的发生

1. 一个线程对同一个互斥量加锁两次, 第1此加锁成功, 第2此加锁则会阻塞, 那么线程自身就会陷入死锁
2. 线程1拥有互斥量A, 并试图访问互斥量B, 线程2拥有互斥量B, 并试图访问互斥量A, 则两个线程都将阻塞

死锁的避免

1. 对互斥量进行排序, 总是以相同的顺序对互斥量进行加锁
2. 使用 pthread_mutex_trylock 接口, 如果成功返回, 则可以继续前进, 如果不能获取锁, 则先释放已经占有的锁, 做好清理工作, 然后过一段时间再试

# 读写锁

读写锁与互斥量的功能类似，对临界区的共享资源进行保护. 互斥量一次只让一个线程进入临界区，不论是对其读还是写, 读写锁比互斥量有更高的并行性. 如果是读，则可以多个线程进入临界区，如果是写，则只让一个线程进入临界区.

# 读写锁的特点

1. 如果一个线程用读锁锁定了临界区，那么其他线程也可以用读锁来进入临界区，这样就可以多个线程并行操作。但这个时候，如果再进行写锁加锁就会发生阻塞，写锁请求阻塞后，后面如果继续有读锁来请求，这些后来的读锁都会被阻塞. 这样避免了读锁长期占用资源，防止写锁饥饿
2. 如果一个线程用写锁锁住了临界区，那么其他线程不管是读锁还是写锁都会发生阻塞

# 条件变量

1. 条件变量本身可以是互斥锁所保护的临界资源
2. pthread_cond_wait 函数不满足时，会解锁互斥量并挂起，满足后，会加锁互斥量并继续执行

# 自旋锁 spin

1. 自旋锁与互斥量功能一样，唯一一点不同的就是互斥量阻塞后休眠让出cpu，而自旋锁阻塞后不会让出cpu，会一直忙等待，直到得到锁
2. 自旋锁，是内核为了支持多CPU而提出的, 自旋锁在用户态使用的比较少，在内核使用的比较多！
3. 自旋锁的使用场景：锁的持有时间比较短，或者说小于2次上下文切换的时间。
4. 自旋锁在用户态的函数接口和互斥量一样，把 pthread_mutex_xxx() 中 mutex 换成 spin，如: pthread_spin_init()

# 屏障 barrier

1. 屏障与互斥量，读写锁，自旋锁不同，它不是用来保护临界区的. 相反，它跟条件变量一样，是用来协同多线程一起工作
2. 条件变量是多线程间传递状态的改变来达到协同工作的效果。屏障是多线程各自做自己的工作，如果某一线程完成了工作，就等待在屏障那里，直到其他线程的工作都完成了，再一起做别的事。
3. 对于条件变量。在接力赛跑里，1号队员开始跑的时候，2，3，4号队员都站着不动，直到1号队员跑完一圈，把接力棒给2号队员，2号队员收到接力棒后就可以跑了，跑完再给3号队员。这里这个接力棒就相当于条件变量，条件满足后就可以由下一个队员(线程)跑。
4. 对于屏障。在百米赛跑里，比赛没开始之前，每个运动员都在赛场上自由活动，有的热身，有的喝水，有的跟教练谈论。比赛快开始时，准备完毕的运动员就预备在起跑线上，如果有个运动员还没准备完(除去特殊情况)，他们就一直等，直到运动员都在起跑线上，裁判喊口号后再开始跑。这里的起跑线就是屏障，做完准备工作的运动员都等在起跑线，直到其他运动员也把准备工作做完.

# 参考

1. [进程间的通信（互斥锁、条件变量、读写锁、文件锁、信号灯）-chumojing-ChinaUnix博客](http://blog.chinaunix.net/uid-12461657-id-3182843.html)
2. [linux线程同步(3)-读写锁](http://www.cnblogs.com/yuuyuu/p/5143881.html)
3. [浅析pthread_cond_wait - weihe6666 - ITeye技术网站](http://weihe6666.iteye.com/blog/1170141)
4. [linux线程同步(5)-屏障](http://www.cnblogs.com/yuuyuu/p/5152560.html)
