# 同步与异步

1. 同步和异步关注的是消息通信机制 (synchronous communication, asynchronous communication).
2. 同步, 发出一个调用时, 在没有得到结果之前, 该调用就不返回. 一旦调用返回, 就得到返回值了. 换句话说, 就是由调用者主动等待这个调用的结果.
3. 异步, 调用在发出之后, 这个调用就直接返回, 所以没有返回结果. 换句话说, 当一个异步过程调用发出后, 调用者不会立刻得到结果, 而是在调用发出后, 被调用者通过状态, 通知来通知调用者, 或通过回调函数处理这个调用. 典型的异步编程模型比如 Node.js.
4. 同步通信机制举例: 你打电话问书店老板有没有《分布式系统》这本书, 如果是同步通信机制, 书店老板会说, 你稍等, 我查一下, 然后开始查啊查, 等查好了(可能是5秒, 也可能是一天), 告诉你结果(返回结果).
5. 异步通信机制举例: 书店老板直接告诉你我查一下啊, 查好了打电话给你, 然后直接挂电话了(不返回结果). 然后查好了, 他会主动打电话给你. 在这里老板通过“回电”这种方式来回调.

# 阻塞与非阻塞 block and non-block

1. 阻塞和非阻塞关注的是程序在等待调用结果(消息, 返回值)时的状态.
2. 阻塞调用是指调用结果返回之前, 当前线程会被挂起. 调用线程只有在得到结果之后才会返回.
3. 非阻塞调用指在不能立刻得到结果之前, 该调用不会阻塞当前线程.
4. 阻塞举例: 你打电话问书店老板有没有《分布式系统》这本书, 你如果是阻塞式调用, 你会一直把自己“挂起”, 直到得到这本书有没有的结果.
5. 非阻塞举例: 如果是非阻塞式调用, 你不管老板有没有告诉你, 你自己先一边去玩了, 当然你也要偶尔过几分钟 check 一下老板有没有返回结果.
6. 阻塞与非阻塞与是否同步异步无关, 即跟老板通过什么方式回答你结果无关.
7. 在处理 IO 的时候, 阻塞和非阻塞都是同步 IO. 只有使用了特殊的 API 才是异步 IO.

# 网络进程通信中的阻塞与非阻塞

1. 阻塞方式(block)指进程或线程执行函数调用时必须等待某个事件的发生, 如果事件没有发生, 进程或线程就被阻塞, 函数不能立即返回
2. connect, accept, recv, recvfrom 函数调用采用阻塞方式
3. 非阻塞方式(non-block)指进程或线程执行函数调用时不必等待事件的发生, 一旦执行肯定返回, 以返回值的不同来反映函数的执行情况, 如果事件发生则与阻塞方式相同, 若事件没有发生则返回一个代码来告知事件未发生, 而进程或线程继续执行, 执行效率较高
4. select 函数采用非阻塞方式, 能够监视需要监视的文件描述符的变化情况, 即读写或是异常

# 回调函数



# 参考

1. [怎样理解阻塞非阻塞与同步异步的区别？](http://www.linuxidc.com/Linux/2015-07/120338.htm)
