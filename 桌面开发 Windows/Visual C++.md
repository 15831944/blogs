# Windows 程序内部运行原理

1. 句柄(handle): 句柄是资源的标识, 操作系统通过句柄来找到相应的资源进行管理和操作. 类似于C中的指针, 类似于UNIX中的文件描述符
2. 句柄的类型: 图标句柄(HICON), 光标句柄(HCURSOR), 窗口句柄(HWND), 应用程序实例句柄(HINSTANCE)等.
3. 窗口句柄: 操作系统给每个窗口指定一个唯一的标识号即窗口句柄.

1. typedef 的作用: 从变量的类型区分变量的用途
1. 消息队列: FIFO的缓冲区
1. Windows程序入口 WinMain 函数, 参数(由操作系统传入): 当前应用程序实例句柄, 先前实例句柄(Win32程序时总为空), 命令行(字符串指针), 显示状态(最大化, 隐藏)
1. 函数调用约定(Calling convention): 参数传递顺序, 堆栈清除的差别, CALLBACK 即 \_stdcall

设计并注册窗口类(WNDCLASS)

1. WNDCLASS 类数据成员: 窗口类的类型, 窗口过程函数, 类附加内存, 窗口附加内存, 实例句柄, 图标句柄(显示在窗口左上角), 光标句柄, 画刷句柄(窗口背景色), 菜单名字(常量字符串), 窗口类名称
2. 窗口类的类型(Class styles): 位掩码, 水平重画, 垂直重画,
3. 窗口过程函数: 回调函数, 由操作系统调用, 由用户定义和实现(消息响应代码), 函数参数(固定不变): 窗口句柄, 消息标识符, 两个消息参数

创建显示和更新窗口

1. CreateWindow 函数参数: 窗口类名称, 窗口标题, Window Styles, 位置坐标, 宽高, 父窗口句柄, 菜单句柄, 实例句柄,
1. ShowWindow UpdateWindow 函数

消息循环

1. 接收发送给此窗口的消息 GetMessage 函数, 对消息对进行转换(产生新的消息), 分配给操作系统调用窗口过程函数进行处理
1. 消息框 MessageBox
1. GetDC 和 ReleaseDC(用于响应 WM_LBUTTONDOWN 消息), BeginPaint 和 EndPaint (只用于响应 WM_PAINT 消息)配对使用

程序终止

1.

# 掌握 C++

1. 标准输入输出流 cin, cout, cerr, 对应C中的文件指针 stdin, stdout, stderr
2. 结构体是特殊的类, 可以通用, 结构体的成员可见性默认为 public, 类的成员默认为 private
3. 默认构造函数由C++编译器在程序没有自定义的构造函数时提供
4. 函数仅返回值类型不同或调用形式相同(调用时不传入有默认值的参数)时, 不能构成重载
5. 对象的成员函数的参数名和数据成员名相同时, 编译器会当作是参数名
6. this 指针等同于 this = &obj, 是面向编译器的而非程序员的, 没有实体指针存在, 在MFC编程中输入this->时会自动列出所有成员函数便于查找
7. 通过继承, 子类可以访问父类的非同名方法, 通过指定父类的域, 子类可以访问父类的同名方法, 通过函数隐藏, 子类可以访问子类的同名方法, 通过虚函数的覆盖, 指向子类的父类可以访问子类的同名方法, 否则父类指针将访问父类的方法
8. 构造子类必须先构造父类, 父类的构造函数由参数时, 可以在子类的构造函数的初始化列表中调用父类的该构造函数
9. 子类继承自父类的成员函数和父类用的是相同的函数实体, 父类中有虚函数, 子类中没有同名函数时, 仍可以访问父类的该函数, 所以虚函数的实体是单独的一份拷贝因此占用内存资源较大, 还是只是多了虚函数表占用的内存
0. 基本数据类型或类的强制类型转换需要内存模型相符
1. 引用是变量名的别名, 是给编译器看的, 本身不是实体, 没有单独的地址, 而指针本身是一个变量, 自身是一个占用内存空间的实体, 引用常用于传参, 用的是参数本身, 而不需要赋值压栈等操作
2. 虚函数, 内联函数等等这些函数的类型只需要在函数声明位置标明其关键字, 在函数定义位置不用
3.

# 参考

孙鑫VC++视频教程
Platform SDK: Windows User Interface
Platform SDK: Windows GDI
