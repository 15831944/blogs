# 进程

1. 进程: 进程是系统中正在运行的一个应用程序, 可以包含多个线程, 一个进程中的所有线程共享可执行程序代码和全局数据
2. 进程空间: 进程运行在其专有的空间内, 是受保护的, 一个进程不能访问另一个进程的专有空间, 获得其资源

进程的五态模型

1. 新建: 进程被创建但还未提交的状态, 新建态的进程无法运行, 因为需要操作系统给出进程管理信息: 建立资源表格, 分配资源, 加载程序, 建立地址空间表等
2. 就绪: 新建后具备所有进程管理信息, 一旦时间片轮转到, 即可运行
3. 运行: 运行态的进程数小于等于处理器的核心数, 当没有进程可运行时, 操作系统会指定系统空闲进程
4. 阻塞: 等待或睡眠状态, 等待某事件发生(如 I/O 请求),  此时即使处理器分配给此进程也无法运行
5. 终止: 操作系统要回收资源, 释放主存

# 线程

1. 线程: 线程是进程的基本执行单元, 用于指代一个独立执行的代码路径, 进程的所有任务都在线程中执行, 例如 Xcode 进程中, 编辑, 保存, 编译, 下载均是独立的线程
2. 主线程(Main Thread): 进程要执行任务必须至少有一个线程, 称为主线程, iOS 中称为 UI 线程, 描绘用户界面, 处理触摸屏幕事件等

线程状态

1. ready
2. cancelled
3. executing
4. finished
5. asynchronous

# 多线程

1. 多线程的作用: 在主线程中执行耗时任务会妨碍 RunLoop 主循环的执行, 导致不能刷新用户界面, 程序画面长时间停滞, 因此将耗时任务放到多线程中执行
2. 多线程的本质: 操作系统为每个线程分配时间片, 对每个线程按时间片轮转调度
3. 多线程的优点: 多线程可以简化编程模型, 更加轻量级, 提高执行效率(一个任务多个人干), 提高资源利用率, 但增加程序复杂性(资源共享, 数据读写问题), 占用内存空间, 增加 CPU 调度开销
4. iOS 多线程实现技术方案包括: pThread, NSThread, GCD, NSOperation 共4种方案, 封装程度递增, 效率递减, 其中 pThread 和 GCD 实现为 C 语言
5. 创建线程时应指定 selector 作为该线程要执行的任务
6. 线程优先级:
7. 线程堆栈:

任务执行方式

1. 同步(串行), 多个任务按照一定顺序执行, 总耗时等于各任务时间相加, 上一个任务执行的结果可用于下一个任务, 任务的执行会阻塞当前线程, 只存在一个线程也就是主线程
2. 异步(并行), 多个任务并发执行, 总耗时等于耗时最长的那个任务, 本质是多个线程
3. 并行：多个任务在同一时刻发生, 对于多核操作系统, 多核 CPU 同时开启多条线程供多个任务同时执行, 互不干扰, 异步执行, 是真正的并行(并行的线程数小于核心数)
4. 并发(Concurrency)：多个任务在同一时间间隔内发生, 在线程之间进行多次上下文切换, 对于单核操作系统, 一个线程执行时, 其他线程阻塞或空闲, 宏观来看是并行, 实际为串行

线程同步方式

1. 线程安全(thread-safe): 使用互斥量保护临界区, Foundation 框架通常被视为线程安全的, UIKit 框架则不是, 所有方法调用都应从主线程执行
2. 互斥量(mutex exclusion): 一个线程更新临界区时锁定其他线程

## NSThread

1. NSThread 类直观, 简单, 快捷, 但不能对线程进行详细配置, 不推荐使用
2. MSLock 类为对象加锁, NSCondition 类对代码块加锁, @synchronized 命令将当前对象加锁
3. NSTask 类可以分出一个子进程来执行其它工作或进行进度监控

## NSOperation

1. NSOperationQueue 执行线程池的最大线程数
2. NSInvocationOperation 子类: 同步方式, 阻塞当前线程
3. NSBlockOperation 子类
4. 自定义子类
5. 依赖关系: addDependency 添加依赖, 相互依赖会造成死锁
6. 线程队列:

# 参考

博客

1. [iOS系统库头文件中NS_AVAILABLE相关](http://www.jianshu.com/p/55adac99377b)
2. [小笨狼漫谈多线程：NSThread](http://www.cocoachina.com/ios/20160225/15421.html)
3. [NS_DESIGNATED_INITIALIZER宏 ](http://www.cocoachina.com/bbs/read.php?tid-282223.html)
