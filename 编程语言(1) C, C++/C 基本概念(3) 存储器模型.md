# Memory model

Defines the semantics of computer memory storage for the purpose of the C abstract machine.
The data storage (memory) available to a C program is one or more contiguous sequences of bytes. Each byte in memory has a unique address.

出于 C 抽象机器的目的定义计算机存储器的语义

C 程序可用的数据存储是一个或多个连续的字节。内存中每个字节有唯一的地址。

## Byte

A byte is the smallest addressable unit of memory. It is defined as a contiguous sequence of bits, large enough to hold any member of the basic execution character set (the 96 characters that are required to be single-byte). C supports bytes of sizes 8 bits and greater.
The types char, unsigned char, and signed char use one byte for both storage and value representation. The number of bits in a byte is accessible as CHAR_BIT.

字节是内存中最小的可寻址单元。字节被定义为连续的位，足够大支持基本执行字符集(需为单字节的96个字符)的任意成员。C 支持8位或更大的字节。类型 char, unsigned char, 和 signed char 使用一个字节用于存储和值的表示。一个字节的位数可由 CHAR_BIT 获取。

## Memory location

A memory location is
an object of scalar type (arithmetic type, pointer type, enumeration type)
or the largest contiguous sequence of bit fields of non-zero length

存储位置是一个标量类型(算术类型 指针类型 枚举类型)的对象或非零长度的位域的最大的连续序列

```
struct S {
    char a;     // memory location #1
    int b : 5;  // memory location #2
    int c : 11, // memory location #2 (continued)
          : 0,
        d : 8;  // memory location #3
    struct {
        int ee : 8; // memory location #4
    } e;
} obj; // The object 'obj' consists of 4 separate memory locations
```

## Threads and data races

A thread of execution is a flow of control within a program that begins with the invocation of a top-level function by thrd_create or other means.

可执行程序的线程是指程序中的一个控制流，以 thrd_create 或其他方式的顶级函数的调用开始

Any thread can potentially access any object in the program (objects with automatic and thread-local storage duration may still be accessed by another thread through a pointer).

任何线程能够潜在地访问程序中的任何对象(automatic 和 thread-local 存储期的对象可仍然被通过这个点的另一个线程访问)

Different threads of execution are always allowed to access (read and modify) different memory locations concurrently, with no interference and no synchronization requirements. (note that it is not safe to concurrently update two non-atomic bit-fields in the same structure if all members declared between them are also (non-zero-length) bit-fields, no matter what the sizes of those intervening bit-fields happen to be)

可执行程序的不同线程总是被允许并发地访问(读取和修改)不同的存储器位置，无阻碍和同步请求。注意，并发的更新同一个结构体中的两个非自动存储期的位域是不安全的，如果在它们之间的所有被声明的成员也是位域(非零长度)，不论这些干预的位域大小是多少。

When an evaluation of an expression writes to a memory location and another evaluation reads or modifies the same memory location, the expressions are said to conflict. A program that has two conflicting evaluations has a data race unless either

both conflicting evaluations are atomic operations

one of the conflicting evaluations happens-before another (see memory_order)

当一个表达式的赋值向内存位置写操作并且另一个赋值操作读取和修改相同的内存位置，此表达式被称为冲突的。具有两个冲突的赋值操作的程序存在数据竞争，除非以下2种情况的任一种：

1. 冲突的赋值操作都是自动类型的操作
2. 一个冲突操作另一个前发生

If a data race occurs, the behavior of the program is undefined.
(in particular, mtx_unlock is synchronized-with, and therefore, happens-before mtx_lock of the same mutex by another thread, which makes it possible to use mutex locks to guard against data races)
This section is incomplete
Reason: small example or two

# Memory order

When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See memory_order for details on the order in which writes made from threads become visible to other threads.

# 参考

[Memory model](http://en.cppreference.com/w/c/language/memory_model)
