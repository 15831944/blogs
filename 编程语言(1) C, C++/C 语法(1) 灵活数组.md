最近看ucc源码，在类型子系统中有一个类型RecordType（记录结构，包括union和struct），这个结构中有一个hasFlexArra域，文档指出是用于标识是否含有灵活数组

灵活数组是添加到C99新特性，称之为incompleted type，不完全类型，俗称零数组（zero array），查询了资料，做了实验，做个笔记

- #include <stdio.h>
- #include <stdlib.h>
- struct zeroarray{
-  main(){
-     struct zeroarray te;
-     printf("%d\n"sizeof(te));
-     printf("%d\n"sizeofstruct zeroarray));
-     struct zeroarray *za;
-     za=(struct zeroarray *)malloc(sizeofsizeof
-     za->b[0]=
-     za->b[1]=
-     printf("%c,%c\n",za->b[0],za->b[1]);
-     printf("%d\n"sizeof(za));
-     printf("%d\n"sizeof(*za));
-     return

#include <stdio.h>
#include <stdlib.h>

struct zeroarray{
int a;
char b[];
};

int main(){
struct zeroarray te;
printf("%d\n",sizeof(te));
printf("%d\n",sizeof(struct zeroarray));

struct zeroarray *za;
za=(struct zeroarray *)malloc(sizeof(int)+2*sizeof(char));

za->b[0]='A';
za->b[1]='B';
printf("%c,%c\n",za->b[0],za->b[1]);

printf("%d\n",sizeof(za));
printf("%d\n",sizeof(*za));
return 0;
}

输出为：

4
4
A,B
4
4
请按任意键继续. . .

用法其实很简单，除了给结构体分配本身需要的内存外，再多分配一些内存，代码自己来控制，即实现了灵活性，由此也可以推导出：灵活数组必须是结构体的最后一个字段

sizeof(struct zeroarray)=sizeof(int)=4编译器在栈中根本没有为char b[]分配空间，所以如下代码会造成栈毁坏（stack corrupted）

- struct zeroarray za;
- za.b[0]=
- za.b[1]=
- printf("%c,%c\n",za.b[0],za.b[1]);

struct zeroarray za;

za.b[0]='A';
za.b[1]='B';

printf("%c,%c\n",za.b[0],za.b[1]);

引用一段 ”印度阿三“<网名> 的话：

这个被称为灵活/弹性数组成员(fleible array member)C89不支持这种东西，C99把它作为一种特例加入了标准。但是，C99所支持的是incomplete type，而不是zero array，形同int item[0];这种形式是非法的，C99支持的形式是形同int item[];只不过有些编译器把int item[0];作为非标准扩展来支持，而且在C99发布之前已经有了这种非标准扩展了，C99发布之后，有些编译器把两者合而为一。

下面是C99标准内容：

6.7.2.1 Structure and union specifiers
    As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member. With two exceptions, the flexible array member is ignored. First, the size of the structure shall be equal to the offset of the last element of an otherwise identical structure that replaces the flexible array member with an array of unspecified length.106) Second, when a . (or ->) operator has a left operand that is (a pointer to) a structure with a flexible array member and the right operand names that member, it behaves as if that member were replaced with the longest array (with the same element type) that would not make the structure larger than the object being accessed; the offset of the array shall remain that of the flexible array member, even if this would differ from that of the replacement array. If this array would have no elements, it behaves as if it had one element but the behavior is undefined if any attempt is made to access that element or to generate a pointer one past it.

注意区分 C99新增的“可变长数组”：
C89 标准规定，数组大小必须是在编译时刻确定的；在C99 中，这个标准项被扩展，可以是运行时刻确定的值。也就是说， 可变长数组和 C++ 本身没有关系，只要是支持 C99 的就可以使用可变长数组，包括支持 C99 的 C 编译器。

需要注意的是，可变长数组的维数在数组生存期内是不变的，也就是说，可变长数组不是动态的，可变的只是数组的大小。

# 参考

[C99灵活数组-incompleted array](http://blog.csdn.net/zhccl/article/details/7837330)
