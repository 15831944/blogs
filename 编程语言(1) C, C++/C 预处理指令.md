# 1 宏定义 #define #undef

## 1.1 宏定义概述

1. 宏定义指令定义了一个标识符(宏名)及一个字符串, 在源程序中每次遇到该标识符时, 均以定义的字符串替换它(宏替换)
2. 宏名和参数间不能有空格, 标识符和字符串间可有任意空格
3. 字符串中应习惯对宏参数加上括号, 这样使用宏时, 如果实参是表达式，则不易出错
4. 宏替换只作宏名和参数替换，不做计算，不做表达式求解
5. 宏一旦被定义后, 其宏名即可成为其它宏定义的一部分
6. 一条宏定义只能写在一行, 可以使用续行符

## 1.2 宏定义与函数调用比较

1. 宏替换在编译前进行，不分配内存, 只占用编译时间, 速度快, 增加代码长度, 可以设法得到多个值, 宏参数替换不存在类型，也没有类型转换
2. 函数调用在程序运行时进行，并分配内存, 占用运行时间, 具有调用时开销(分配内存, 保留现场, 值传递, 返回值), 只有一个返回值, 存在参数的哑实结合

## 1.3 宏定义参数的操作符

操作符和宏参数之间可以有任意数量的空格，而不会被当作字符串的一部分

| 操作符 | 含义                        |
| ----- | -------------------------- |
| #     | stringizing   字符串化操作符 |
| ##    | token-pasting 符号连接操作符 |
| @#    | charizing     字符化操作符   |

# 2 文件包含 #include

1. 文件包含指令使编译器将指定的文件嵌入源文件中执行该指令的位置
2. 文件包含指令可以嵌套使用, 称为嵌套的嵌入文件, 嵌套层次依赖于具体实现
3. 被嵌入的文件名必须用双引号或尖括号括起来, 文件检索方式不同

# 3 编译指示(杂注) #pragma

1. 编译指示指令对每个编译器给出了一个方法, 在保持与C和C++完全兼容的情况下, 给出主机专有特征
2. 编译指示是机器或操作系统专有的，且对于每个编译器都是不同的
3. 编译指示可以设定编译器的状态或指示编译器完成一些特定的动作

## 3.1 编译指示参数

1. message 参数能够在编译信息输出窗口中输出相应的信息, 可用于输出控制代码版本的宏
2. code_seg 参数能够指定函数在目标文件中存放的节, 可用于开发驱动程序
3. once 参数能够保证头文件只被编译一次, 添加到头文件起始位置即可
4. hdrstop 参数表示预编译头文件结束位置, BCB可以预编译头文件以加快链接的速度，但如果所有头文件都进行预编译又可能占太多磁盘空间, 所以使用这个选项排除一些头文件
5. startup 参数指定编译优先级, 用于文件之间存在依赖关系的情况, 如果使用了 `#pragma package(smart_init)`, BCB就会根据优先级先后编译
6. warning 参数允许有选择性的修改编译器的警告消息行为, 可以使用push和pop保存和弹出警告状态或使用标识符(once, default, n, disable, error)处理指定序号的警告消息
7. comment 参数将一个注释记录放入一个对象文件或可执行文件中
8. pack 参数指定对象的对齐宽度
9. always_inline
10. no_aliass

# 4 编译出错 #error

1. 编译出错指令强迫编译程序停止编译，主要用于程序调试, 在程序崩溃之前能够给出一定的信息
2. 编译出错指令使预处理器发出一条错误消息，该消息包含指令中的文本

# 5 条件编译 #if，#ifdef, #ifndef, #elif，#else，#endif

1. 条件编译指令可对程序源代码的各部分有选择地进行编译, 该过程称为条件编译
2. 商业软件使用条件编译提供和维护某一程序的许多顾客版本
3. #if指令后面的表达式在编译时求值, 因此必须是常量, 且不允许含有sizeof操作符, 虽然sizeof是编译时求值
4. 在嵌套的条件编译中, #endif, #else 或 #elif 与最近 #if 或 #elif 匹配

# 6 修改文件指定行 #line

1. 主要用于调试及其它特殊应用

# 7 参考

1. [ 关于#pragma code_seg](http://blog.csdn.net/whatday/article/details/7100855)
2. [#pragma详细解释](http://blog.csdn.net/nodeman/article/details/45477067)
