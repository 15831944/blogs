# 概述

1. C++ 中必须声明函数原型, 参数列表为空则相当于 void (在 C 中则意味着在后面定义参数列表), 可变参数列表使用"..." c++ primer plus 7.1.2
2. 函数原型描述了函数到编译器的接口, 在编译时可能访问不到函数定义(可能在另一个文件中), 只能用原型
3. 实参(argument)和形参(parameter), 形参是函数私有的, 类似局部变量
4. 传值调用时, 函数新建形参名的变量, 并将实参的值拷贝给形参, 而不是使用实参本身, 实参还压在栈中?
5. 使用数据区间(超尾), 即指向数组首元素的指针和指向数组末尾元素后面位置的指针作为函数参数, 代替传统的以数组名和数组长度作为参数 7.3.4
6. 传址调用的缺点是有改变原参数的风险, 因此使用 const 关键字修饰形参, 只适用于基本数据类型的形参 p225
7. 使用 const 修饰的形参, 既能够传入变量, 也能传入常量, 否则只能传入变量, 即不能将常量实参传给变量形参 p223
8. C++中, main 函数不允许递归调用

# 函数指针

1. 使用函数名作为函数参数, 传入的是函数指针, 即函数的地址 c++ primer plus 7.10
2. 使用函数调用作为函数参数, 是先调用函数, 再将函数返回值传入
3. 虚函数是有函数指针数组实现的

使用引用作为形参和使用指针作为形参的区别?

1. 引用形参被初始化为实参的别名, 引用参数将指向实参的地址

# 引用

1. 引用总是指向一个对象, 不能为空, 因此声明时必须初始化, 在使用前也就不需要测试其有效性, 引用的代码效率也就比使用指针的要高
2. 引用不能指向其他对象, 相当于常量指针, 即指针的内容不变, 指向的变量的内容可变
3. 引用是变量的别名, 或者说是某块内存的别名, 而指针是一个实体, 因此 sizeof 对引用返回的是指向的变量的大小, 对指针则返回指针本身的大小
4. 引用的主要功能是传递函数的参数和返回值. C++ 语言中，函数的参数和返回值的传递方式有三种: 值传递, 指针传递和引用传递
5. 引用可以做的任何事情, 指针也都能够做，之所以要用引用是因为“用适当的工具做恰如其分的工作”, 较使用指针更加安全
7. 引用常量: 使用 const 限定符修饰引用, 则引用的值不可改变, 而引用的变量的值时可以改变的

# 右值引用 rvalue reference

&&

# 按值传递, 按地址传递, 按引用传递

1. 按值传递的实参的形式比较随意, 可以是表达式等, 返回时也需要将返回值返回到一个临时位置, 即返回的是右值, 运行下一条语句时, 返回值可能就不再存在
2. 按引用传递的实参必须是变量名
3. 对于常量引用, 如果实参与引用形参不匹配, 则形参会引用实参转换而来的临时变量, 因为是常量, 函数并不打算修改实参, 因此是可行的, 但对于变量引用, 则临时变量的方式是无法修改实参的, 因此会报错
4. 返回引用的函数实际上是被引用的变量的别名, 避免了按值传递时的拷贝操作
5. 返回引用常量, 使得返回值是不可修改的左值, 依然可以在其他函数中用作参数使用
6. 传址调用是形参指向了实参
7. 传递类对象参数的标准方式是引用传递
