# 多态的必要性

1. 使用 delete 操作符销毁一个对象指针指向的对象时, 只会销毁该对象和其继承的对象, 即会执行该类的析构函数和其父类的析构函数
2. 使用基类对象指针指向派生类对象, 销毁该指针时, 若派生类动态申请了资源, 则由于没有调用派生类的析构函数造成内存泄漏
3. 使用基类对象指针指向派生类对象, 调用继承关系的类中的同名的成员函数时, 由于是基类的指针, 会调用到基类的成员函数, 往往不是想要的结果

# 多态概述

1. 多态的定义: 相同对象收到不同消息或不同对象收到相同消息时产生不同的动作, 叫做多态
2. 多态的语义: 使用基类对象指针指向各个派生类对象, 并可以通过该指针调用与基类同名的派生类各自的成员函数(正常会调用到基类的该成员函数), 同一个基类指针, 指向派生类的对象, 就调用该派生类对象的哪个函数, 即相同对象收到不同消息产生不同动作
3. 声明虚函数: 使用 vitrual 关键字修饰继承关系的基类中的同名的成员函数, 则派生类中的同名成员函数也会变成虚函数, 这样就建立多个类之间的多态关系
4. 静态多态(早绑定): 对于互为重载的函数(同名不同参), 在编译阶段就已经确定要调用哪个函数了, 叫做早绑定
5. 动态多态(晚绑定): 使用 virtual 关键字修饰成员函数或析构函数, 解决派生类对象的成员函数的访问和派生类对象的资源释放问题, 属于动态多态
6. 虚成员函数: 使用 virtual 关键字修饰的基类的成员函数, 则派生类中的同名的成员函数也会成为虚函数
7. 虚析构函数: 使用 virtual 关键字修饰的基类的析构函数, 则派生类的析构函数也会成为虚析构函数(析构函数名不同, 因为析构函数名同类名)
8. 虚函数特性可以被继承: 只需要将基类的成员函数或析构函数使用 virtual 关键字修饰即可, 派生类中的成员函数也应使用 virtual 关键字修饰可便于阅读
9. 产生多态的基础是继承关系, 没有继承就没有多态
10. A派生B, B包含堆中的C, 则构造顺序为ABC, 析构顺序为BCA(不是CBA)
11. 一般而言, 父类指针就是执行父类的成员函数, 子类就是执行子类的成员函数, 但对于虚函数来说, 由于多了指向虚函数列表的指针这个成员, 父类指针能访问到子类的非独有的数据成员(父类和子类相同的成员结构部分), 当基类的指针指向派生类的对象时, 执行到的虚成员函数和虚析构函数都变成了子类的

# virtual 关键字修饰函数时的限制

1. 只有类的成员函数和析构函数可以是虚函数
2. 内联函数不能是虚函数, 如果使用 virtual 修饰内联函数, 则编译器会忽略 inline 关键字, 而会将该函数变成虚函数
3. 静态(static)成员函数不能是虚函数, 否则会产生语法错误, 因为静态成员函数不属于任何具体的对象, 而是和类同生共死的
4. 构造函数不能使虚函数, 否则会产生语法错误
5. 普通函数(全局)不能是虚函数, 否则会产生语法错误

# 虚函数的实现原理

1. 基类定义了一个虚函数, 并且派生类没有同名函数, 此时, 派生类会继承基类的这个虚函数
2. 每个对象在实例化后, 都会生成一个虚函数表和一个指向虚函数表的指针这样一个数据成员
3. 同一个类实例化出的所有对象都共用同一份虚函数表和值相同的指向虚函数表的指针, 即同类的所有对象的不同的虚函数被统一规划到一个大而全的表中
4. 虚函数表的内容是指向该类的对象定义的虚函数的入口地址
5. 若要调用虚函数, 需要先找到指向虚函数表的指针, 在找到虚函数表, 再根据该虚函数在虚函数表中的便宜位置找到指向该虚函数的指针, 然后执行该虚函数
6. 派生类具有自己的虚函数表, 由于派生类继承了基类的虚函数, 所以在派生类的虚函数表的相同的偏移位置会存放指向基类的该虚函数的指针
7. 如果在派生类中定义了与基类同名的虚函数, 则派生类的虚函数表中的该虚函数的偏移位置的内容将被派生类的同名的虚函数覆盖, 这样每个对象访问的就都是自己的虚函数了
8.基类的对象指针指向派生类的对象, 调用该同名虚函数时, 由于基类的对象指针可以访问派生类的数据成员, 因此会通过派生类的虚函数表指针找到派生类的虚函数并执行
9. 继承关系的两个对象中的同名的成员函数, 如果是同名的普通成员函数, 子类的成员函数会隐藏父类的同名成员函数, 如果是同名的虚函数, 则子类的虚函数会覆盖父类的同名虚函数

# 虚析构函数的实现原理

1. 销毁一个子类时, 执行完子类的析构函数会执行其父类的析构函数, 因此应使用父类对象指针指向子类对象, 在 delete 父类对象指针引用的对象时, 要想销毁父类的同时, 也能销毁子类, 就应执行子类的析构函数(然后自动调用父类的析构函数), 就能够正确销毁该子类对象, 避免造成内存泄漏
2. 由于虚析构函数也是可以被继承的, 因此只要基类有虚析构函数, 派生类也会生成虚析构函数(尽管不同名), 存在于子类的虚函数表中
3. 基类的对象指针指向派生类的对象, 调用析构函数时, 由于基类的对象指针可以访问派生类的数据成员, 因此会通过派生类的虚函数指针找到派生类的虚析构函数并执行, 因此便可正确的销毁子类对象

# 对象

1. 对象的大小: 实例化对象后, 对象的数据成员所占用的内存大小
2. 对象的地址: 对象所占用的内存中, 第一个内存单元的地址
3. 对象成员的地址:
4. 指向虚函数列表的指针: 具有虚函数的对象的首个内存地址存的就是这个指针成员, 占用4字节
5. 如果一个对象不存在任何数据成员, 对象实例化后, 则其理论大小应为0, 但为了标记该对象的存在, 为其分配了一个字节的内存, 如果有数据成员, 例如一个32位的整数, 则对象的大小就是这个整型的大小, 即为4, 就不存在之前的1了
6. 如果对象有虚函数, 则会存在一个32位宽度的指针成员

# 纯虚函数

1. 没有实现的虚函数为纯虚函数
3. 纯虚函数定义没有函数体, 后面写 "=0", 表示纯虚函数指针的内容为0
3. 虚函数表中的纯虚函数指针是空指针, 即纯虚函数没有实现

# 抽象类

1. 只要含有纯虚函数的类叫做抽象类
2. 由于纯虚函数没有实现, 即无法调用, 因此抽象类不允许实例化对象, 只能被继承
3. 抽象类的子类可以是(子类含有纯虚函数)也可以不是(子类不含有纯虚函数)抽象类
4. 抽象类的子类直到把继承的抽象类的纯虚函数都做了实现, 该子类才能被实例化对象

# 接口类

1. 仅含有纯虚函数的类叫做接口类, 即类中仅含有成员函数, 且成员函数都是纯虚函数, 没有任何数据成员
2. 接口类用来表达能力或协议
3. 接口类定义一般只需要头文件, 不需要源文件, 因为没有任何实现

接口类举例1

1. Flyable 接口类: 会飞是一种能力, 若要实现会飞的能力, 应定义 takeoff 和 land 两个纯虚函数, 继承此类的子类应实现这两个纯虚函数
2. Bird 类: 继承 Flyable 接口类, 若要实例化此类, 必须实现父类中 takeoff 和 land 两个纯虚函数
3. flyMatch 函数: 参数是 Flyable 类的对象指针, 要求传入 Flyable 的子类(Flyable自身是接口类, 不能实例化, 不能传入 Flyable 类, 避免了传入未实现 Flyable 能力的对象)
4. 由于 Bird 子类 "是一个" Flyable 父类, 因此可以传入 Bird, 并能通过父类指针调用子类(注意是子类, 多态的体现)实现的 takeoff 和 land 函数
5. Flyable 可以理解为一种协议, 即只要会飞的, 那么一定实现了 takeoff 和 land 函数(才能实例化并传入), 则都可以参加飞行比赛

接口类举例2

1. CanShot 接口类: 具备射击能力, 应定义 aim 和 reload 两个纯虚函数
2. Plane 类: 多继承, 继承 Flyable 接口类和 CanShot 接口类, 若要实例化此类, 必须实现两个父类中的 takeoff, land, aim, reload 纯虚函数
3. fight 函数: 参数是 CanShot 类的对象指针, 要求传入 CanShot 的子类, 且 Plane 类的对象时可以传入的

接口类举例3

1. Plane 类: 继承 Flyable 接口类, 需要实现 takeoff 和 land 虚函数
2. FlighterJet 类: 多继承, 继承 Plane 普通类和 CanShot 接口类, 已具有 takeoff 和 land, 需要实现 aim 和 reload 虚函数
3. airBattle 函数: 参数是 FlighterJet 类的对象指针, 要求既要会飞又要能战斗, 则此函数中可以安全地调用 Flyable 接口类和CanShot 接口类定义的函数

# typeid

1. 返回一个 type_info 对象的引用
2. 如果想要通过基类的指针获得派生类的数据类型, 基类必须带有虚函数, 否则只能返回定义时的基类的数据类型
3. 满足上条的情况下, 只能获取对象的实际类型(当前对象时基类还是子类), 不能判断对象指针的类型

```
class type_info{
public:
	const char *name() const;						// 数据类型名称
	bool operator == (const type_info&rhs) const;	// 操作符重载
	bool operator != (const type_info&rhs) const;
	int before(const type_info&rhs) const;
	virtual ~type_info();
private:
	...
}
```

# 动态类型转换 dynamic_cast

1. 只能用于对象的指针或引用的转换, 而不能是对象本身
2. 要转换的和被转换的类型中, 必须包含虚函数, 即必须是多态类型
3. 如果转换成功, 则返回子类的地址, 否则返回 NULL

# 运行时类型识别, RTTI, run-time type identification

1. 识别出父类指针指向的是哪个子类对象

# 异常 exception

1. 异常: 指运行时错误
2. 异常处理: 对有可能发生异常的地方做出预见性的安排, 未处理的异常会被抛给系统, 系统会杀死该进程
3. 常见异常: 网线未插, 内存不足(一般由于内存泄漏造成), 数组下标越界, 除数为0, 文件读写错误
4. try{ throw obj }catch( int ){  }catch(...){  } 尝试捕获异常, 主逻辑与异常处理逻辑分离
5. try 中的主逻辑如果抛出了异常, 则主逻辑不再继续运行, catch 就会捕获异常并进行处理
6. 抛出的异常的类型应和 catch 的参数类型对应
7. 主逻辑中可能抛出多种异常, 可以由多个 catch 分别捕获
8. catch 的参数是 ... 时, 可以捕获任意异常, 一般用于前面都处理不了的默认处理情况
9. 异常传播方向: 不断向上层调用者抛出, 交由其处理, 如果所有调用函数都无法处理, 最终就会被抛给系统
10. 定义"异常"这个接口类, 并作为 catch 的参宿, 异常处理就可以是子类的异常处理成员函数了
