# 多态的必要性

1. 使用基类对象指针指向派生类对象, 使用 delete 销毁该指针指向的派生类对象时, 正常只会销毁该对象和其继承的父类对象, 即会执行该类的析构函数及其父类的析构函数, 若派生类有动态申请的资源, 则由于没有调用派生类的析构函数, 造成内存泄漏
2. 使用基类对象指针指向派生类对象, 调用继承关系中的类的同名的成员函数时, 由于是基类的指针, 会调用到基类的成员函数, 而不是派生类的成员函数

# 多态的应用

1. 使用"游戏角色"这个基类作为形参, 则可以传入"各职业角色"这些子类, 以相同的操作(例如掉血)对各个不同的派生类做不同的处理了
2. 定义"异常"这个接口类, 并作为 catch 的参数, 异常处理就可以是各子类的异常处理成员函数了

# 多态的实现原理

1. 同一个类实例化出的每个对象在实例化后, 都会生成一个指向该类共有的虚函数表的指针这样一个公有的可继承的数据成员, 即每个对象的虚函数指针的值是相同的, 指向同一个虚函数表的, 同类的所有对象的不同的虚函数被统一规划到一个表中, 虚函数表的内容是指向该类的对象定义的虚函数的入口地址, 这样, 基类指针若指向基类对象, 则依然可以访问基类的原成员函数, 基类指针若指向派生类对象, 则可以通过派生类对象的虚函数指针访问派生类对象的同名的虚函数
2. 虚函数特性可以被继承, 只需要将基类的成员函数或析构函数使用 virtual 关键字修饰即可(派生类中的成员函数也应使用 virtual 关键字修饰可便于阅读), 派生类的虚函数会覆盖派生类的虚函数表中的原基类同名虚函数的位置

# 虚函数

1. 虚函数的声明: 使用 vitrual 关键字修饰继承关系的基类中的同名的成员函数, 则派生类中的同名成员函数也会变成虚函数, 这样就建立多个类之间的多态关系
2. 虚函数的本质: 虚函数是原成员函数的一份拷贝, 是同名但独立的实体, 会造成资源开销
3. 虚成员函数: 使用 virtual 关键字修饰的基类的成员函数, 则派生类中的同名的成员函数也会成为虚函数
4. 虚析构函数: 使用 virtual 关键字修饰的基类的析构函数, 则派生类的析构函数也会成为虚析构函数(析构函数名同类名, 因此彼此之间不用同名)

# 虚函数的限制

1. 只有类的成员函数和析构函数可以是虚函数
2. 虚函数需要同名同参, 即同名不同参的虚函数会被认为是不同的虚函数

其他类型函数不能是虚函数的原因: 

1. 内联函数: 内联函数并非真正可调用的函数实体, 若将内联函数声明为虚函数, 编译器会将该函数变成虚函数
2. 静态成员函数: 静态成员函数不属于任何具体的对象, 而是和类同存的, 一个类的所有对象都只能访问这一个静态成员函数
3. 构造函数: 构造子类必须先构造父类
4. 全局函数: 与类和对象无关

# 多态的概述

1. 多态的定义: 相同对象收到不同消息, 或不同对象收到相同消息时, 产生不同的动作, 叫做多态, 多态是对于基类和派生类而言的, 产生多态的基础是继承关系, 有了继承, 父类指针才能访问到子类的虚函数指针这个成员, 进而以相同的偏移位置访问到子类的同名虚函数
2. 多态的语义: 使用基类对象指针指向各个派生类对象, 并可以通过该指针调用与基类同名的派生类各自的成员函数(正常会调用到基类的该成员函数), 使得同一个基类指针指向哪个派生类的对象, 就调用该派生类对象的哪个函数, 使得基类的形参, 可以接受任何派生类对象, 在函数中调用同一个函数时, 实际调用的是各子类的成员函数

# 多态的分类

1. 静态多态(早绑定): 对于互为重载的函数(同名不同参), 在编译阶段就已经确定要调用哪个函数了, 叫做早绑定
2. 动态多态(晚绑定): 对于虚成员函数或虚析构函数, 在运行时, 使用基类对象指针解决派生类对象的成员函数的访问和派生类对象的资源释放问题, 属于动态多态

10. A派生B, B包含堆中的C, 则构造顺序为ABC, 析构顺序为BCA(不是CBA)

# 虚函数的实现原理

1. 若基类定义了一个虚函数, 并且派生类没有同名函数, 此时, 派生类会继承基类的这个虚函数, 所以在派生类的虚函数表的相同的偏移位置会存放指向基类的该虚函数的指针
2. 若在派生类中定义了与基类同名的虚函数, 则派生类的虚函数表中的该虚函数的偏移位置的内容将被派生类的同名的虚函数的地址覆盖, 这样每个对象访问该名称的虚函数时, 就可以按照相同的偏移地址访问指向该虚函数的指针, 然后执行该虚函数
3. 虚函数之所以叫虚函数, 我认为是因为这些同名函数本身是不同的实体, 但在调用时, 同一时刻又只可能调用到其中一个

# 虚析构函数的实现原理

1. 销毁一个子类时, 常规情况下, 执行完子类的析构函数会执行其父类的析构函数, 因此应使用父类对象指针指向子类对象, 在 delete 父类对象指针引用的对象时, 要想销毁父类的同时, 也能销毁子类, 就应执行子类的析构函数(然后自动调用父类的析构函数), 就能够正确销毁该子类对象, 避免造成内存泄漏
2. 由于虚析构函数也是可以被继承的, 因此只要基类有虚析构函数, 派生类也会生成虚析构函数(尽管不同名), 存在于子类的虚函数表中, 基类的对象指针指向派生类的对象时, 调用析构函数就会通过派生类的虚函数指针找到派生类的虚析构函数并执行(然后自动调用父类的析构函数), 因此便可正确的销毁子类对象

# 函数的重载, 覆盖, 隐藏

1. 函数的重载是对于同一个类中的函数而言的, 同名不同参, virtual 关键字可有可无
2. 函数的覆盖是对于继承关系的不同类的函数而言的, 同名同参且有 virtual 关键字
3. 函数的隐藏是对于继承关系的不同类的函数而言的, 同名不同参, 或同名同参无 virtual 关键字
1. 继承关系的两个对象中的同名的成员函数如果是普通成员函数, 子类的成员函数会隐藏父类的同名成员函数, 如果是同名的虚函数, 则子类的虚函数会覆盖父类的同名虚函数, 但覆盖的是虚函数表中的内容, 两个同名函数依然是不同的实体

# 指向虚函数列表的指针的存储

1. 对象的大小是实例化对象后, 对象的数据成员所占用的内存大小, 对象的地址是对象所占用的内存中, 第一个内存单元的地址
2. 指向虚函数列表的指针具有虚函数的对象的首个内存地址存, 且指针成员占用4字节
3. 如果一个对象不存在任何数据成员, 对象实例化后, 则其理论大小应为0, 但为了标记该对象的存在, 为其分配了1个字节的内存
4. 如果一个对象有数据成员, 例如一个32位的整数, 则对象的大小就是这个整型数据的大小, 即4个字节, 就不存在标记对象存在的1个字节了
5. 如果一个对象有虚函数, 则会存在一个32位的指针成员, 若没有其他成员, 则该对象的大小应是4字节

# 纯虚函数

1. 纯虚函数的定义: 没有实现的虚函数为纯虚函数
2. 纯虚函数的声明: 纯虚函数定义没有函数体, 后面写 "=0", 表示纯虚函数指针的内容为0, 即虚函数列表中纯虚函数指针是空指针, 纯虚函数没有实现, 存放的该虚函数的地址为0

# 抽象类

1. 至少含有一个纯虚函数的类叫做抽象类
2. 由于纯虚函数没有实现, 即无法调用, 因此抽象类不允许实例化对象, 只能被继承
3. 抽象类的子类可以是(含有纯虚函数)也可以不是(不含有纯虚函数)抽象类
4. 抽象类的子类直到把继承的抽象类的纯虚函数都做了实现, 该子类才能被实例化对象
5. 抽象类会增加虚函数表, 使对象的体积翻倍, 甚至降低可移植性, 一般只有基类会声明为抽象类, 基类必须要有一个虚析构函数
6. 在 java 中，含有抽象方法的类称为抽象类，同样不能用于实例化对象

# 接口类

1. 只含有纯虚函数的类叫做接口类, 即类中仅含有成员函数, 且成员函数都是纯虚函数, 没有任何数据成员
2. 接口类可以用来表达能力或协议
3. 接口类定义一般只需要头文件, 不需要源文件, 因为没有任何实现

接口类举例1

1. Flyable 接口类: 会飞是一种能力, 若要实现会飞的能力, 应定义 takeoff 和 land 两个纯虚函数, 继承此类的子类应实现这两个纯虚函数
2. Bird 类: 继承 Flyable 接口类, 若要实例化此类, 必须实现父类中 takeoff 和 land 两个纯虚函数
3. flyMatch 函数: 参数是 Flyable 类的对象指针, 要求传入 Flyable 的子类(Flyable自身是接口类, 不能实例化, 不能传入 Flyable 类, 避免了传入未实现 Flyable 能力的对象)
4. 由于 Bird 子类 "是一个" Flyable 父类, 因此可以传入 Bird, 并能通过父类指针调用子类(注意是子类, 多态的体现)实现的 takeoff 和 land 函数
5. Flyable 可以理解为一种协议, 即只要会飞的, 那么一定实现了 takeoff 和 land 函数(才能实例化并传入), 则都可以参加飞行比赛

接口类举例2

1. CanShot 接口类: 具备射击能力, 应定义 aim 和 reload 两个纯虚函数
2. Plane 类: 多继承, 继承 Flyable 接口类和 CanShot 接口类, 若要实例化此类, 必须实现两个父类中的 takeoff, land, aim, reload 纯虚函数
3. fight 函数: 参数是 CanShot 类的对象指针, 要求传入 CanShot 的子类, 且 Plane 类的对象时可以传入的

接口类举例3

1. Plane 类: 继承 Flyable 接口类, 需要实现 takeoff 和 land 虚函数
2. FlighterJet 类: 多继承, 继承 Plane 普通类和 CanShot 接口类, 已具有 takeoff 和 land, 需要实现 aim 和 reload 虚函数
3. airBattle 函数: 参数是 FlighterJet 类的对象指针, 要求既要会飞又要能战斗, 则此函数中可以安全地调用 Flyable 接口类和CanShot 接口类定义的函数

# typeid

1. 返回一个 type_info 对象的引用
2. 如果想要通过基类的指针获得派生类的类型, 基类必须带有虚函数, 否则只能返回定义时的基类的数据类型
3. 满足上条的情况下, 只能获取对象的实际类型(当前对象时基类还是子类), 不能判断对象指针的类型

```
class type_info{
public:
	const char *name() const;						// 数据类型名称
	bool operator == (const type_info&rhs) const;	// 操作符重载
	bool operator != (const type_info&rhs) const;
	int before(const type_info&rhs) const;
	virtual ~type_info();
private:
	...
}
```

# 动态类型转换 dynamic_cast

1. 只能用于对象的指针或引用的转换, 而不能是对象本身
2. 要转换的和被转换的类型中, 必须包含虚函数, 即必须是多态类型
3. 如果转换成功, 则返回子类的地址, 否则返回 NULL

# 运行时类型识别, run-time type identification, RTTI

1. 识别出父类指针指向的是哪个子类对象

# 异常 exception

1. 异常: 指运行时错误
2. 异常处理: 对有可能发生异常的地方做出预见性的安排, 未处理的异常会被抛给系统, 系统会杀死该进程
3. 常见异常: 网线未插, 内存不足(一般由于内存泄漏造成), 数组下标越界, 除数为0, 文件读写错误

# 异常的捕获

4. try{ throw obj }catch( int ){  }catch(...){  } 尝试捕获异常, 主逻辑与异常处理逻辑分离
5. try 中的主逻辑如果抛出了异常, 则主逻辑不再继续运行, catch 就会捕获异常并进行处理
6. 抛出的异常的类型应和 catch 的参数类型对应
7. 主逻辑中可能抛出多种异常, 可以由多个 catch 分别捕获
8. catch 的参数是 ... 时, 可以捕获任意异常, 一般用于前面都处理不了的默认处理情况

# 异常传播方向

1. 不断向上层调用者抛出, 交由其处理, 如果所有调用函数都无法处理, 最终就会被抛给系统
