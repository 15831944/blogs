# 1 数据封装 Encapsulation

1. 将数据成员和成员函数封装成一个对象
1. 数据成员一般以字母 m 开头
2. 成员函数(方法)

# 2 对象的实例化

1. 从栈中实例化的对象由系统自动释放对象, 使用 "." 操作符访问数据成员和成员函数
2. 从堆中实例化的对象需要手动释放对象, 使用 "->" 操作符访问数据成员和成员函数

```
类名 对象名;					// 从栈中定义对象
类名 对象名[];				// 从栈中定义对象数组
类名 *ptr = new 对象名();	// 从堆中定义对象指针
类名 *arr = new 对象名[];	// 从堆中定义对象数组指针
delete ptr;
delete []arr;
```

# 对象的初始化

1. 对于局部变量，声明后用赋值语句初始化即可
2. 对于对象，由于存在多个成员数据，因此需要编写初始化函数
3. 初始化函数需要手动调用，而构造函数随对象的创建而自动调用，用后者进行初始化更加方便

# 数据的初始化

1. C 语言使用赋值(等号形式)初始化, 为了形式统一, 基本标量数据类型的初始化也可以使用直接初始化形式
3. 从栈中实例化对象时, 调用默认构造函数时, 不能使用空括号, 因为会将默认构造函数调用误判为函数声明
4. 从堆中实例化对象时, 由于存在 new 运算符, 不会误判, 则可以有空括号, 当然也可以不写括号
5. 构造函数的初始化列表只支持基本数据类型, 不支持数组或结构, 成员初始化的顺序取决于类中成员定义的顺序, 而非初始化列表中的顺序
7. STL容器的初始化: 可以初始化一个空的容器, 或复制别的容器, 只能用默认构造函数进行初始化, 不能使用自定义构造函数初始化

# 对象的直接初始化(括号形式)

1. 若参数是要初始化的数据成员, 直接调用以数据成员作为参数的构造函数
2. 若参数是已经存在的该类对象, 直接调用以对象作为参数的拷贝构造函数
3. 总结: 对象的直接初始化会直接调用与实参匹配的构造函数

# 对象的复制初始化(等号形式)

1. 若赋值操作符的右操作数是要初始化的数据成员, 则先调用指定构造函数, 为数据成员创建一个临时对象，然后调用拷贝构造函数将该临时对象复制到正在创建的对象
2. 若赋值操作符的右操作数是已经存在的该类对象, 则由于对象已经存在, 不再需要创建临时对象, 直接调用拷贝构造函数将指定的对象复制到正在创建的对象
3. 总结: 对象的赋值初始化总会调用拷贝构造函数, 因此, 拷贝构造函数必须为公有

# 编译器对对象初始化的优化

1. 若编译器的优化级别够高, 且该类具有显式定义的公有的构造函数, 可能会将赋值初始化优化为调用该构造函数的直接初始化, 从而省去创建临时对象的步骤
2. 编译器无法对不支持赋值的类，或者使用非显式的构造函数的类做此优化


# 内存管理

1. 内存是由操作系统控制的资源, 应用程序可以向操作系统申请和归还内存资源, 申请的内存在堆中
2. 申请和释放操作必须配套且成对使用, 即 new 和 delete, malloc 和 free
3. 一旦重复调用了 delete, 内存被重复回收, 系统就会出现错误
4. 使用 new 运算符申请内存时, 应使用指针接收申请到的内存地址, 分配失败则返回空指针
5. 使用 delete 运算符释放内存(由操作系统回收)后, 应将指针设置为空, 否则该指针还指向已经被释放的那块内存,

```
int *ptr = new int;
int *arr = new int[10];
delete ptr;
delete []arr;
ptr = NULL;
arr = NULL;
```

# 内联函数

1. 使用 inline 关键字声明内联函数
2. 编译时将函数体代码和实参代替函数调用语句, 实参的值直接赋值给形参
3. 内联函数是建议性的, 编译器决定如何处理
4. 内联函数适用于逻辑简单(如不包含 for 循环), 调用频繁的函数
5. 递归函数无法使用内联函数

# 3 成员函数在类外定义

1. 类内定义: 成员函数定义在类的内部, 编译器会优先编译成内联函数
2. 类外定义: 成员函数定义在类的外部
3. 同文件类外定义: 成员函数的声明和定义在同一个文件中
4. 分文件类外定义: 成员函数在头文件中声明, 在源文件中定义, 源文件需要包含头文件

# 函数参数默认值

1. 必须从最右侧参数开始连续的赋函数参数默认值, 有默认值的参数必须写在参数列表的最右端
2. 函数参数默认值应写在函数声明中, 不应写在函数定义中, 若写在函数定义中, 有些编译器可能无法通过
3. 函数调用时, 有实参则会采用实参, 无实参则用默认值

# 函数重载

1. 函数名相同, 参数类型和个数不同的函数互为函数重载, 函数的返回值类型无所谓
2. 编译器使用函数名加参数类型形成新的函数名, 以区分不同函数
3. 互为重载的函数必须在相同作用域内

```
int    max(int x, int y)		// 实际名称变为 max_int_int
double max(double x, double y)	// 实际名称变为 max_double_double
```

# 4 程序和对象的存储结构

1. 对象的存储结构: 类在实例化前是不占用内存的, 对象实例化后对象的成员数据在栈中分配内存, 成员函数在代码区, 同类型的对象使用同一个代码区的函数实现代码
2. 对象的初始化: 两种, 有且仅有一次初始化和根据条件初始化

| 内存分区 | 说明 |
| ------ | --- |
| 栈区   | 定义变量, 指针等, 系统自动回收内存
| 堆区   | 使用 new 定义的对象, 手动管理内存
| 全局区 | 存储全局变量和静态变量
| 常量区 | 存储字符串常量
| 代码区 | 存储二进制逻辑代码

# 5 构造函数 constructor

1. 构造函数可以防止忘记调用或多次调用初始化函数
2. 构造函数在对象实例化是被自动调用, 常用于对象的初始化, 因此可将初始化代码写在构造函数中
3. 构造函数名称与类名相同, 访问限定为公有, 没有返回值(void 也不用写)
4. 构造函数可以有多个重载形式
5. 实例化对象时, 如果存在多个构造函数, 则实际仅会用到其中一个
6. 当用户没有定义构造函数时, 编译器自动生成一个默认的构造函数, 函数体为空
7. 构造函数可以无参数或有参数
8. 在构造函数中申请的内存应在析构函数中释放

# 6 默认构造函数 default constructor

1. 实例化对象语句后带小括号时, 会调用默认构造函数
2. 实例化对象时不需要传递参数的构造函数称为默认构造函数
3. 无参或参数全都有默认值的构造函数都为默认构造函数

# 7 构造函数的初始化列表

1. 初始化列表只能用于构造函数, 先于构造函数执行
2. 初始化列表可以同时初始化多个数据成员, 效率更高
3. 初始化列表的必要性: 给 const 成员常量赋初始值, 因为 const 常量不能先定义, 后再赋值

# 8 拷贝构造函数 copy constructor

```
构造函数名( const 类名 &对象名 ){}	// 构造函数名必须与类名一致
```

1. 当采用直接初始化或复制初始化来实例化对象时(即用一个对象初始化另一个对象会发生拷贝), 系统自动调用拷贝构造函数
2. 在对象作为参数传递时(也会发生对象的拷贝), 系统也会自动调用拷贝构造函数
3. 当用户没有定义拷贝构造函数时, 编译器自动生成一个默认的拷贝构造函数
4. 拷贝构造函数的参数确定为某个对象, 因此不能够重载

# 9 析构函数

1. 在对象被销毁时(程序返回或调用 delete 销毁对象)自动调用, 用于释放动态申请的内存资源
2. 析构函数没有返回值, 不允许带任何参数(也即不可重载)
3. 当用户没有定义析构函数时, 编译器自动生成一个默认的析构函数
4. 通过拷贝构造函数实例化的对象在销毁时也会调用析构函数
5. 析构函数不能重载

# 10 对象数组

1. 使用 new 运算符实例化对象数组时, 数组中的对个对象元素都要调用一遍构造函数
2. 使用 delete 销毁对象数组时, 数组中的每个对象元素也都会调用一遍析构函数, 如果不使用中括号[], 则只会释放第一个元素, 造成内存泄漏
3. 需要注意用于存储对象数组的指针当前指向哪个元素, 释放时, 指针应指向第1个元素
4. 成员数据如果不进行初始化会是随机值

# 11 对象成员

1. 如果对象A中有对象成员B和C, 实例化对象A时会按照对象B, 对象C, 对象A的顺序进行构造, 销毁对象1时会按照对象A, 对象C, 对象B的顺序销毁
2. 如果对象A中有对象成员B, 而对象B没有默认构造函数(无参或参数均有默认值时有默认构造函数, 有参数但没有默认值时没有默认构造函数), 那么对象A必须在初始化列表中初始化对象B

# 12 拷贝构造函数中的深拷贝和浅拷贝

1. 浅拷贝就是数据成员之间直接一一进行赋值拷贝, 将原对象的数据成员的值一一赋给通过拷贝实例化的新对象. 但是可能会有这样的情况：对象还包含资源, 这里的资源可以指堆资源或者一个文件. 例如, 对象的数据成员是指针并且指向申请的堆内存时, 当进行浅拷贝的时候, 两个对象就有用共同的资源, 可以同时对资源可以访问, 即指针内容相同会导致通过拷贝实例化的对象的成员与原对象指向同一块内存, 这样就会出问题, 例如会导致销毁对象时, 堆内存被回收两次, 出现运行时错误而崩溃.
2. 深拷贝就是用来解决这样的问题的, 它把资源也拷贝一次, 使对象拥有不同的资源, 但资源的内容是一样的. 对于堆资源来说, 就是新开辟一片堆内存, 对原来堆中的内容进行拷贝, 因此, 拷贝构造函数中应重新申请内存, 并将指针指向的内容进行拷贝, 而不是拷贝指针本身的内容(地址)
3. 引用和指针的语义是相似的，引用是不可改变的指针，指针是可以改变的引用。其实都是实现了引用语义。深拷贝和浅拷贝的区别是在对象状态中包含其它对象的引用的时候，当拷贝一个对象时，如果需要拷贝这个对象引用的对象，则是深拷贝，否则是浅拷贝。
4. COW 语义是“深拷贝”与“推迟计算”的组合，仍然是深拷贝，而非浅拷贝，因为拷贝之后的两个对象的数据在逻辑上是不相关的，只是内容相同。
5. 无论深浅，都是需要的。当深拷贝发生时，通常表明存在着一个“聚合关系”，而浅拷贝发生时，通常表明存在着一个“相识关系”。

# 引用

1. 引用总是指向一个对象, 不能为空, 因此必须初始化, 在使用前也就不需要测试其有效性, 引用的代码效率也就比使用指针的要高
2. 引用不能指向其他对象, 相当于常量指针, 即指针的内容不变, 指向的变量的内容可变
3. 引用是变量的别名, 或者说是某块内存的别名, 而指针是一个实体, 因此 sizeof 对引用返回的是指向的变量的大小, 对指针则返回指针本身的大小
4. 引用的主要功能是传递函数的参数和返回值. C++ 语言中，函数的参数和返回值的传递方式有三种: 值传递, 指针传递和引用传递
5. 引用可以做的任何事情, 指针也都能够做，之所以要用引用是因为“用适当的工具做恰如其分的工作”, 较使用指针更加安全
7. 引用常量: 使用 const 限定符修饰引用, 则引用的值不可改变, 而引用的变量的值时可以改变的

# 13 对象指针

1. 指向对象的指针, 使用 new 运算符实例化的对象指针指向的是对象的第1个数据成员
2. \*p 表示该对象, 可以使用 . 操作符, p 使用 -> 操作符访问数据成员
3. 对象指针也可以指向通过栈实例化的对象

# 14 对象成员指针

1. 对象指针作为另一个对象的成员
2. 可以使用初始化列表将其初始化为 NULL 指针或在构造函数中使其指向使用 new 操作符实例化的对象
3. sizeof 对象时, 其大小是所有数据成员的总和, 若成员是指针, 则是所有对象成员指针本身大小的总和
4. 在析构函数中销毁对象时, 应销毁对象成员指针指向的对象的内存

# 15 this 指针

1. 对象的数据成员和成员函数的参数同名, 导致编译器无法分辨
2. this 指针是指向对象自身数据的指针
3. 实例化一个对象, 则 this 指针就是这个对象的地址, this 放在哪个对象中就指的是哪个对象的地址, 可以访问该对象的数据成员, 起标记数据成员作用
4. 成员函数如何访问到对应的数据成员, 实际上编译器自动的将成员函数添加了 this 指针这个参数, 传递到成员函数实现的代码区
5. 若成员函数返回值类型设置为该对象类型, 然后函数返回 \*this, 则函数返回的是一个临时对象
6. 若成员函数返回值类型为该对象的引用, 即在类型名后面加上引用符号 &, 则会返回此对象, 若返回类型为该对象的指针, 即在类型名后面加\*符号, 函数返回 this 本身, 则得到此对象的指针

# 16 常对象成员

1. 常数据成员需要用初始化列表赋值, 不能用数据封装函数赋值, 因为常量必须在定义时初始化
2. 是类的属性，而非某个具体对象的属性
3. static 在这里的含义是每个类中只含有一个

# 17 常成员函数

1. 在成员函数声明和定义的后面加 const 关键字, const 实际上修饰的是 this 指针
2. 在常成员函数中不能修改数据成员的值, 因为此时成员函数的隐含的参数 this 指针变成了指针常量, 所以修改常指针指向的数据成员是不合法的
3. 常成员函数和同名的普通成员函数互为重载, 这样的函数调用时, 如果实例化的对象时常对象, 即用 const 修饰, 则调用的是常成员函数, 否则调用普通的同名的成员函数
4. 常对象只能调用常成员函数, 因为普通成员函数对成员具有读写权限, 而常对象对其成员只具有读权限, 不能用小权限调用大权限
5. 常成员函数不能调用普通的成员函数
6. 常成员函数中可以使用普通的数据成员, 但是不能改变对象成员的值
7. 普通对象能够调用普通成员函数, 也能调用常成员函数

# 18 常对象, 常指针, 常引用

1. 对象的常指针的意思是指针指向的对象是常量, 该对象只具有读权限, const 修饰的是 \*p, 而对象指针常量的意思是该指针只能指向这个对象, 不能更改, 该对象依然是具有读写权限的, const 修饰的是 p 本身
2. 对象的常指针或常引用只能调用常成员函数, 因为只读权限的对象不能调用读写权限的函数, 对象的常指针和常引用在调用成员函数时, 效果类似于长对象本身
3. 一个对象可以由多个对象常引用

# 参考

1. [C++远征之起航篇](http://www.imooc.com/learn/342)
2. [C++远征之离港篇](http://www.imooc.com/learn/381)
3. [C++远征之封装篇（上）](http://www.imooc.com/learn/382)
4. [C++远征之封装篇（下）](http://www.imooc.com/learn/405)
5. [C++远征之继承篇](http://www.imooc.com/learn/426)
6. [C++远征之多态篇](http://www.imooc.com/learn/474)
7. [C++远征之模板篇](http://www.imooc.com/learn/477)
8. [C++实战（一）：走出迷宫](http://eksea.com/2015/12/26/cpptraining001/)
9. 《易学C++》

1. [浅拷贝(shallow copy)和深拷贝(deep copy)](http://blog.sina.com.cn/s/blog_5928f2dd0100h6k9.html)
2. [开贴讨论:浅拷贝和深拷贝!(3)](http://dev.wikl.net/52238-3.html)

1. [C＋＋初始化与赋值](http://www.cnblogs.com/chio/archive/2008/10/06/1305145.html)
2. [c++中，引用和指针的区别](http://blog.csdn.net/dujiangyan101/article/details/2844138)
3. [C++的一大误区——深入解释直接初始化与复制初始化的区别](http://blog.csdn.net/ljianhui/article/details/9245661)
