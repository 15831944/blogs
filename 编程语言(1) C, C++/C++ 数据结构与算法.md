# 数据结构

1. 数据结构是指相互之间存在一种或多种特定关系的数据元素的集合，需要程序员自行用且类很适合用类来实现，保证只能用类的成员函数接口指定的方式去访问, 可用于实现如软件算法

# 队列 queue

1. 先进先出(FIFO, first in first out)，队头出队，队尾入队，使用数组实现队列, 对头和队尾是数组下标, 队尾是最后一个元素后面的位置, 不能插队

1. 普通队列: 队列头, 队列尾，队列头离开后，后面的成员可以前移，会浪费时间，不前移会浪费空间
2. 环形队列: 顺时针排队, 逆时针排队，队列空间占满后，队列头就和队列尾重叠，能够充分利用内存空间, 对头可能在队尾后面

# 栈 stack

1. 后进先出(LIFO, last in first out), 空栈, 栈容量
2. 栈要素: 栈顶, 栈底, 栈顶用来执行压栈和出栈操作, 并可以体现栈的当前大小以及是满还是空, 使用数组实现栈, 栈顶是数组下标, 是最后一个元素后面的位置, 栈底一直不变
3. 使用 visit 函数作为参数传入栈的遍历成员函数, 对栈进行遍历操作
4. 栈适用的算法: 十进制转换成其他进制使用的短除法

# 线性表 linear list

1. 线性表是n个数据元素的有限序列, 数据项(item), 记录(record), 可进行插入操作
2. 线性表适用于通讯录这种长度不限的序列, 新建联系人可按首字母顺序插入指定的位置, 内容是节点的数据项

1. 顺序表: 用数组实现, 前驱, 后继, 位序, 查找快, 插入删除慢
2. 链表: 节点包括数据域和指针域, 节点可以是类或结构体, 链表不限制容量大小, 头节点标识链表的存在, 数据域没有意义, 不算入链表长度, 头节点后面的节点的位序是0, 头节点不是其前驱

1. 单链表: 由头节点开始依次指向尾节点, 尾节点指向 NULL
2. 循环链表: 尾节点的指针域指向头节点
3. 双向链表: 节点有正向和反向两个指针域
4. 静态链表: 数组起始位置为头节点, 指针域为数组下标, 尾节点的指针域为0

# 树

1. 树是节点的有限集合, 可用于压缩软件(赫夫曼树), 人机对战(树的搜索), 根节点(树根), 终端节点(叶子, 没有孩子的节点), 父节点(父亲), 子节点(孩子), 祖先(所有的上级节点), 子孙(所有的下级节点)
2. 有序树和无序树: 有序指终端节点不能调换位置, 即子节点分左右
3. 度: 当前节点的直接的孩子(子节点)的个数
4. 深度: 节点深度(节点所在层), 树的深度(节点的最大深度)
5. 森林: 多个独立的树或一个树看成多个子树

1. 二叉树: 所有节点的度都小于等于2, 用父节点访问子节点, 因此创建时应具有根节点
2. 二叉树的遍历: 前序遍历(根->左右, 父->子), 中序遍历(左->根->右), 后续遍历(左右->根, 子->父), 遍历时应看成多个子树, 递归的遍历

二叉树的数组实现

1. 左节点的下标为当前节点下标乘以2加1, 右节点为加2, 不存在左节点或右节点则该节点所在下标位置的值为0, 树的容量为数组长度, 创建二叉树时应创建数组并初始化根节点
2. 添加节点时, 可插入的是当前节点(父节点)的左孩子或右孩子(子节点), 且要保证插入之前该位置没有已经有值的节点, 搜索和删除节点可直接使用数组下标, 遍历则遍历数组即可

二叉树的链表实现

1. 树的根节点没有值(链表的头节点的数据域没有意义), 无容量限制, 删除节点会一并删除其所有的子孙
2. 每个节点应具有父节点指针, 左孩子指针, 右孩子指针用于访问与其相关的节点(指针域), 具有唯一的索引号(相当于数组下标)用于访问当前节点, 还要有数据本身(数据域)
3. 搜索节点是通过索引找到节点对象, 要从头节点开始搜索, 而树可以看成多个子树, 一个节点可以是一个子树的根节点, 因此可以用递归函数实现

# 图 map

1. 图是顶点(node)和连线的集合, 双向的连线就相当于没有方向的连线, 用于路径规划(地图导航), 工程规划(修建高速公路计算最小生成树), 战略规划(军事攻击方案)

1. 有向图, 顶点, 弧(arc, 有向), 弧尾, 弧头, 权值, 出度(去向弧的数量), 入度(回向弧的数量)
2. 无向图, 顶点, 边(edge, 无向), 邻接点, 连通图(任意顶点直接或间接的相连), 完全图(所有顶点直接相连), 边数=n(n-1)/2, 生成树, 边数=n-1

图的存储结构

1. 邻接矩阵(二维数组, 有向图和无向图): 顶点的表示: 顶点索引(数组下标), 顶点数据, 弧的表示: 顶点间没有连线为0, 有连线为1, 有权值则直接写为权值, 主对角线为全0, 边的表示: 对称矩阵, 可只记录上三角或下三角, 有容量限制
2. 邻接表(链表, 有向图): 顶点的表示: 顶点索引, 顶点数据, 出弧链表头指针, 弧的表示: 弧头顶点索引, 下一条弧指针, 弧数据(权值)
3. 十字链表(链表, 有向图): 顶点的表示: 顶点索引, 顶点数据, 以该顶点为弧尾的弧节点指针, 以该顶点为弧头的弧节点指针, 弧的表示: 弧尾顶点索引, 弧头顶点索引, 弧尾相同的下一条弧的指针, 弧头相同的下一条弧的指针, 弧数据
4. 邻接多重表(链表, 无向图): 顶点的表示: 顶点索引, 顶点数据, 连接该顶点的边, 边的表示: A顶点索引, B顶点索引, 与A顶点相连接的下一条边的指针, 与B顶点相连的下一条边的指针, 边数据

图的遍历

1. 深度优先搜索: 搜索到形成环为止, 类似树的前序遍历
2. 广度优先搜索: 从上到下一层一层的搜索

最小生成树

1. 普里姆(Prim)算法: 点集合, 边集合, 待选边集合
2. 克鲁斯卡尔(Kruskal)算法: 待选边集合, 已选边集合, 已设计点集合

# 慕课网 C++ 数据结构教程

1. [数据结构探险—队列篇](https://www.imooc.com/learn/519)
2. [数据结构探险—栈篇](https://www.imooc.com/learn/611)
3. [数据结构探险—线性表篇](https://www.imooc.com/learn/651)
4. [数据结构探险—树篇](https://www.imooc.com/learn/673)
5. [数据结构探险—图篇](https://www.imooc.com/learn/672)
