# 向量 vector

1. 向量的本质是对数组的封装, 长度可变, 可以根据存储的元素个数自动的变长或缩短, 实质上使用 new 和 delete 管理内存, 存储在自由存储区, 堆中
2. 向量在随机读取数据时, 能在常数时间内完成, 即无论向量中存储了多少元素, 都可以以同样的时间将元素查找并读取出来
3. 迭代器(iterator): 迭代器变量是一个指针, 可用于访问向量的各个元素, 适用于所有的标准模板库
4. 分配器(allocator): 对象

向量类的对象的初始化

```
vector<T> v1;			// v1是T类型的对象, 默认构造函数为空
vector<T> v2(v1);		// v2是v1的副本
vector<T> v3(n, i);		// v3包含n个值为i的元素
vector<T> v4(n);		// v4包含n个有值初始化元素
```

向量类的成员函数

| function        | describe                   |
| --------------- | -------------------------- |
| empty()         | 判断向量是否为空              |
| begin()         | 返回向量迭代器首元素           |
| end()           | 返回向量迭代器末元素的下一个元素 |
| clear()         | 清空向量                     |
| front()         | 返回第一个数据                |
| back()          | 返回最后一个数据              |
| size()          | 获得向量中数据大小            |
| push_back(elem) | 将数据插入向量尾              |
| pop_back()      | 删除向量尾部数据              |

# 链表 list

1. 链表具有多个节点则第一个为头节点，没有节点则为空链表
2. 每个节点具有数据域和指针域两部分组成，单链表从头节点顺序指到尾，双向链表则又可以从尾顺序找到头
3. 链表的插入数据速度要比向量快，在使用上类似向量，只能使用迭代器访问，没有下标的语法

# 映射 map

1. 映射由键值对 pair 对象组成，通过键访问值，pair 的模板参数类型应该和 map 一致
2. 使用 insert 函数插入键值对，只能使用迭代器遍历，使用 first 和 second 两个数据成员分别表示键和值

```
map<int, string> m;		// 映射
pair<int ,string> p;	// 键值对
```

# 数组 array

1. 长度固定
2. 存储在栈中

at()会检查下标是否越界
