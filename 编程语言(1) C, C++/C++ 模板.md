# 友元函数

1. 在被友元的类中使用 friend 关键字声明该类的友元函数, 使用该类的对象指针或引用作为函数参数
2. 友元函数包括友元全局函数和友元成员函数两种, 后者在声明时, 应指明友元成员函数所属的类(使用类名和域操作符)
3. 友元函数就可以通过传入的对象, 直接访问被友元的类的受保护和私有数据成员和成员函数(公有成员本身就可在类外访问)

# 友元类

1. 在被友元的类中使用 friend 关键字声明该类的友元类
2. 在友元类的实现中可以定义被友元的类的对象, 并任意访问被友元的类的受保护和私有数据成员和成员函数

# 友元的使用

1. 友元破坏被友元的类的封装性, 因此在功能上应视作对封装的补充, 只有在使用封装特性无法达到目的时才会使用友元的方式
1. 友元关系不可传递, A是B的友元, B是C的友元, 不代表A是C的友元, 即A可以访问B, B可以访问C, 但A不能访问C
2. 友元关系具有单向性, A是B的友元, 不代表B是A的友元, 即A可以访问C, 但B不能访问A, 即被友元的类定向的把自己的成员暴露给其友元
3. 友元声明的形式(友元函数还是友元类)和数量不受限制

# 静态数据成员

1. 静态数据成员不依赖于对象, 只依赖于类, 随类的产生而产生, 即若不实例化对象, 该类的静态数据成员也存在于内存中
2. 静态数据成员并不会在构造函数中初始化, 而是需要在类外单独的初始化, 且静态数据成员并不算入对象的大小
3. 静态数据成员举例: 定义一个静态成员变量记录该类实例化的对象的数量, 在类外初始化为0, 在构造函数中进行"++"操作, 在析构函数中进行"--"操作即可
4. 静态数据成员是全局的, 与对象无关的, 在成员函数中访问静态数据成员不存在隐式的 this 指针

# 静态成员函数

1. 普通成员成员可以调用静态数据成员和成员函数
2. 静态成员函数不能调用普通数据成员和成员函数
3. 时机的角度: 因为静态成员函数随类的产生而产生, 而普通的数据成员和成员函数随对象的实例化而产生, 此时,可能还未实例化对象
4. 实现的角度: 静态成员函数不会隐式的传入 this 指针, 无法访问普通成员函数, 因为没有 this 指针就不知道普通数据成员属于哪个对象
5. 静态成员函数中可以访问静态数据成员, 因为静态成员函数和静态数据成员都是全局的(不依赖于对象)
6. 静态成员函数不能使用 const 修饰, 因为 const 本质上修饰的是 this 指针, 而静态成员函数中没有 this 指针

# 静态成员的使用

1. 可以通过类名跟"::"操作符或对象名跟"."操作符这两种方式对静态数据成员和静态成员函数进行访问, 在该类没有实例化对象时, 应使用类名跟"::"操作符方式

# 运算符重载

1. 给原有运算符添加新的功能, 叫做运算符重载, 其本质是函数重载
2. "+"运算符可以将操作数相加, 重载后, 可以拼接字符串, 可以实现两个对象的相加(如坐标类中坐标运算)
3. "<<"操作符重载后, 可以实现对象的输出等

# 操作符重载

2. 操作符重载: 同一操作符对于不同的自定义数据类型可以进行不同的操作
3. 域解析操作符, 成员操作符, 条件操作符, sizeof共4个操作符不允许重载
4. 前增操作符是先增后赋，在操作符重载中，我们理解为先做自增，然后把自增后的操作数本身返回
3. 后增操作符是先赋后增，在操作符重载中，我们理解为先把操作数的值(临时值)返回，然后操作数自增
6. 为了在重载中加以区分，后增操作符多一个整型参数
