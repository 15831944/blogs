# 继承概述

1. 子类和父类对应于派生类和基类
2. 内存中, 子类的数据成员包括自身的和父类的数据成员
3. 子类应包含父类的头文件
4. 父类是子类的超集, 因为子类无法访问父类的私有成员
5. 实例化子类会先调用父类的构造函数, 再调用自身的构造函数
6. 销毁子类会先调用自身的析构函数, 再调用父类的析构函数
7. 父类的私有数据成员不允许继承

# 数据成员访问限定符

1. public, 可以在类内外访问, 可以被继承
2. protect, 仅可以在类内访问, 可以被继承
3. private, 仅可以在类内访问, 不可以被继承

# 继承方式

成员函数如果不是公有会怎样?

1. 继承方式包括公有继承, 保护继承, 私有继承(默认)
3. 对于公有继承, 父类的公有数据成员被继承到子类的公有数据成员中, 子类可以在该子类的内部和外部对其进行访问; 父类的受保护成员被继承到子类的受保护成员中, 即在子类内部允许访问父类的受保护成员, 在子类外部则不能; 父类的私有成员被继承到子类的不可见位置, 即子类不能访问父类的私有成员, 虽然不能访问, 但实际上子类是包含父类的所有数据成员的

| qualifier | 类外 | 类内 |
| --------- | --- | --- |
| public    | 允许 | 允许 |
| proteced  | 禁止 | 允许 |
| private   | 禁止 | 允许 |

1. 第1列是数据成员的访问限定符类型, 第1行是访问本对象的数据成员的语句的位置, 内容是访问权限
2. 类外可以是其他对象的和成员函数中, 也可以是 main 函数中, 类内是指在该类的成员函数内可以访问该类的数据成员
3. 禁止访问表明需要用数据封装函数访问, 不能用成员访问操作符访问, 允许访问表示可以使用成员访问操作符访问, 也可以在该对象的公有的成员函数中访问
4. proteced 和 private 访问限定符修饰的数据成员在不涉及继承的情况下, 其特性是一致的

| inheritance | public   | proteced | private |
| ----------- | -------- | -------- | ------- |
| public      | public   | proteced | n.a     |
| proteced    | proteced | proteced | n.a     |
| private     | private  | private  | n.a     |

1. 第1列是继承方式, 第1行是基类的成员访问属性, 内容是派生类对基类成员的访问属性
2. 如果对象1有公有数据成员a, 对象2私有继承对象1, 则a变成对象2私有的, 此时对象3继承对象2, 则对象3将无法访问a, 即私有继承的成员到本对象为止

# 继承关系中的隐藏

1. 父子关系的子类和父类具有同名的成员函数时, 子类的成员函数会隐藏掉父类的成员函数, 实例化子类对象时, 直接调用则只能访问到子类的该成员函数
2. 同名的数据成员同样隐藏的特性, 但实际意义不大
3. 子类若想访问被隐藏的父类的同名的成员函数或数据成员, 则在调用或使用时, 应指明父类的域
4. 成员函数的隐藏只要求函数名相同, 不要求参数相同, 因此不能互为重载

# 对象, 对象指针, 对象引用作为函数参数

1. 对象作为函数参数时, 实际上是传值调用, 会新建一个临时的对象(调用拷贝构造函数), 函数返回时销毁(调用析构函数)
2. 对象指针或引用作为函数参数时, 实际上是传址调用, 是对象的引用, 不会创建临时对象, 因此效率更高
3. 对象的引用作为函数参数时, 形参是实参的别名

# 有一个的关系(has a)

1. 对象的组合是包含关系, 对象A的私有数据成员有(包含)对象B, 则对象A只能访问对象B的公有数据成员, 因为A是在B类外访问B的成员, 只能通过成员访问操作符访问
3. 私有继承也是包含关系, 子类的私有数据成员有(包含)从父类继承而来的父类的公有数据成员, 子类只能访问父类的公有数据成员, 因为后者能被继承, 同样只能通过成员访问操作符访问
4. “有”的关系，从属关系, 包含关系，如链表有头结点和中间各节点, 线段有两个坐标点, 电脑有处理器

# 是一个的关系(is a)

1. 子类对象可以初始化(从栈中实例化, 拷贝构造父类对象)或赋值给父类对象, 因为子类中必定有父类的数据成员, 可继承的成员将对应被赋值, 子类独有的成员将被截断而丢失
2. 父类对象指针可以指向子类对象, 但只能访问到可由子类继承到的父类的成员, 不能访问到子类独有的成员(访问不全)或调用子类的成员函数(即使是公有)
3. 子类对象作为参数传递给以父类对象指针或引用作为参数的函数时, 因为函数对父类的操作, 传入的子类对象都能够提供, 由于是传址调用, 实际被修改的也是传入的子类的可继承的那部分数据.
4. 父类对象指针指向从堆中实例化的子类对象时, 即实例化了一个子类, 但用父类对象指针对其进行访问, 则在构造子类对象时, 会先调用父类的构造函数, 再调用子类的构造函数, 是正常的, 但在销毁时, 由于是用父类指向子类, 只会调用父类的析构函数, 由于子类对象没有被销毁, 会造成内存泄漏.
5. 父类的析构函数是虚析构函数时, 虚函数可以被继承下去, 所以子类的析构函数也会成为虚析构函数, 这样在销毁由父类指针指向的子类时, 就可正确地先销毁子类对象, 再销毁父类对象
6. 公有/受保护继承是“是”的关系，子类"是一个"父类, 子类可以直接修改父类, 父类对象指针可以直接操作子类, 只不过只能访问可继承的那部分成员
7. "是"的关系, 表示延续，如本科生是学生，自行车是交通工具

# 虚函数

1. 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象
2. 不作为基类的类一般不包含虚函数, 因为后者会增加虚函数表, 是对象的体积翻倍, 甚至降低可移植性
3. 当且仅当类里包含至少一个虚函数的时候才去声明虚析构函数
4. 抽象类是准备被用做基类的，基类必须要有一个虚析构函数，纯虚函数会产生抽象类，在想要成为抽象类的类里应声明一个纯虚析构函数
5. 如果析构函数不是虚函数，则编译器实行静态绑定，在删除基类指针时，只调用基类的析构函数而不调用派生类的析构函数
6. 在 C++ 含有纯虚函数的类称为抽象类，它不能生成对象；在 java 中，含有抽象方法的类称为抽象类，同样不能生成对象

# 多重(级)继承

1. A 派生 B, B 派生 C, 则 A, B, C 之间是多重继承, 如果是公有继承, 则 B 是一个 A, C 是一个 B, C 是一个 A, 即直接或间接子类都是 is a 的关系
2. 实例化继承链中最底层的子类时, 会从基类到派生类一级一级的构造, 销毁时顺序相反

# 多继承

1. 一个子类有多个父类, A 和 B 都是 C 的父类, 如果均是公有继承, 则 C 是一个 A, C 是一个 B, 例如农民工的父类是农民类和工人类
2. 实例化子类时, 会按照初始化列表的顺序依次调用多个父类的构造函数, 后调用子类的构造函数, 销毁时顺序相反

# 菱形继承

1. B和C继承A, D继承B和C, ABD和ACD为多重继承, BCD为多继承
2. D(底层)中会继承2份A(基类)的数据成员, 1份来自B, 1份来自C, 2份同名的成员函数拥有不同的域(B和C), 实例化D时, A会构造和析构2次

# 虚继承

1. B虚继承A, C虚继承A, 使得实例化D时只实例化1次A, 但成员函数无法传入参数
1. B和C虚基类
