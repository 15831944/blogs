# 继承概述

1. 子类和父类对应于派生类和基类
2. 内存中, 子类的数据成员包括自身的和继承自父类的数据成员, 定义子类时应包含父类的头文件, 父类的私有数据成员不允许继承
3. 实例化子类会先调用父类的构造函数, 再调用自身的构造函数, 销毁子类会先调用自身的析构函数, 再调用父类的析构函数

# 数据成员访问限定符

1. public, 可以在类内外访问, 可以被继承
2. protect, 仅可以在类内访问, 可以被继承
3. private, 仅可以在类内访问, 不可以被继承

| qualifier | 类外 | 类内 |
| --------- | --- | --- |
| public    | 允许 | 允许 |
| proteced  | 禁止 | 允许 |
| private   | 禁止 | 允许 |

1. 第1列是数据成员访问限定符类型, 第1行是访问本对象的数据成员的语句的位置, 内容是访问权限
2. 类外可以是其他对象的成员函数中, 也可以是全局函数中, 类内是指在该类的成员函数内可以访问该类的数据成员
3. 禁止访问表明不能用成员访问操作符访问(需要用数据封装函数访问), 允许访问表示可以使用成员访问操作符访问
4. proteced 和 private 访问限定符修饰的数据成员在不涉及继承的情况下, 其特性是一致的, 因此保护的含义是对继承进行保护

# 继承方式

1. 继承方式包括公有继承, 保护继承, 私有继承(默认)
2. 对于公有继承, 父类的公有数据成员被继承到子类的公有数据成员中, 子类可以在该子类的内部和外部对其进行访问; 父类的受保护成员被继承到子类的受保护成员中, 即在子类内部允许访问父类的受保护成员, 在子类外部则不能; 父类的私有成员被继承到子类的不可见位置, 即子类不能访问父类的私有成员, 虽然不能访问, 但实际上子类是包含父类的所有数据成员的, 以免子类赋值给父类时发生语法错误

| inheritance | public   | proteced | private |
| ----------- | -------- | -------- | ------- |
| public      | public   | proteced | n.a     |
| proteced    | proteced | proteced | n.a     |
| private     | private  | private  | n.a     |

1. 第1列是继承方式, 第1行是基类的成员访问属性, 内容是派生类对基类成员的访问属性
2. 如果对象1有公有数据成员a, 对象2私有继承对象1, 则a变成对象2私有的, 此时对象3继承对象2, 则对象3将无法访问a, 即私有继承的成员到本对象为止

# 继承关系中的隐藏

1. 父子关系的子类和父类具有同名的成员函数时, 子类的成员函数会隐藏掉父类的成员函数, 实例化子类对象时, 直接调用则只能访问到子类的该成员函数
2. 同名的数据成员同样具有隐藏的特性, 但实际意义不大
3. 子类若想访问被隐藏的父类的同名的成员函数或数据成员, 则在调用或使用时, 应指明父类的域, 即只能通过父类对象访问
4. 成员函数的隐藏只要求函数名相同, 不要求参数相同, 因此不能互为重载, 重载是对于同类中的函数而言的

# 对象, 对象指针, 对象引用作为函数参数

1. 对象作为函数参数时, 实际上是传值调用, 会新建一个临时的对象(调用拷贝构造函数), 函数返回时销毁(调用析构函数)
2. 对象指针或引用作为函数参数时, 实际上是传址调用, 是对象的引用, 不会创建临时对象, 因此效率更高
3. 对象的引用作为函数参数时, 形参是实参的别名

# 有一个的关系(has a)

1. 对象的组合是包含关系, 对象A的私有数据成员有(包含)对象B, 则对象A只能访问对象B的公有数据成员, 因为A是在B类外访问B的成员, 只能通过成员访问操作符访问
2. 私有继承也是包含关系, 子类的私有数据成员有(包含)从父类继承而来的父类的公有数据成员, 子类只能访问从父类继承的公有数据成员, 同样只能通过成员访问操作符访问
3. “有”的关系，从属关系, 包含关系，如链表有头结点和中间各节点, 线段有两个坐标点, 电脑有处理器

# 是一个的关系(is a)

1. 子类对象可以初始化(从栈中实例化, 拷贝构造父类对象)或赋值给父类对象, 因为子类中必定有父类的数据成员, 可继承的成员将对应被赋值, 子类独有的成员将被截断而丢失, 父类的私有成员呢?
2. 父类对象指针可以指向子类对象, 但只能访问到子类继承自父类的成员, 不能访问到子类独有的成员(访问不全)或调用子类的成员函数(即使是公有)
3. 父类(指针或引用)的形参可以接受子类的实参, 因为函数对父类进行的操作, 传入的子类对象都能够提供, 由于是传址调用, 实际被修改的也是传入的子类的可继承的那部分数据
4. 父类对象指针指向从堆中实例化的子类对象时, 即实例化了一个子类, 但用父类对象指针对其进行访问, 则在构造子类对象时, 会先调用父类的构造函数, 再调用子类的构造函数, 是正常的, 但在销毁时, 由于是用父类指向子类, 只会调用父类的析构函数, 由于子类对象没有被销毁, 会造成内存泄漏, 需将析构函数声明为虚函数
5. 公有/受保护继承是“是”的关系，子类"是一个"父类, 子类可以直接修改父类, 子类可以作为实参传给父类, 父类对象指针可以直接操作子类, 只不过只能访问可继承的那部分成员
6. "是"的关系, 表示延续，如本科生是学生，自行车是交通工具

# 多重(级)继承

1. A 派生 B, B 派生 C, 则 A, B, C 之间是多重继承, 如果是公有继承, 则 B 是一个 A, C 是一个 B, C 是一个 A, 即直接或间接子类都是 is a 的关系
2. 实例化继承链中最底层的子类时, 会从基类到派生类一级一级的构造, 销毁时顺序相反

# 多继承

1. 一个子类有多个父类, A 和 B 都是 C 的父类, 如果均是公有继承, 则 C 是一个 A, C 是一个 B, 例如农民工的父类是农民类和工人类
2. 实例化子类时, 会按照初始化列表的顺序依次调用多个父类的构造函数, 后调用子类的构造函数, 销毁时顺序相反

# 菱形继承

1. B和C继承A, D继承B和C, ABD和ACD为多重继承, BCD为多继承
2. D(底层)中会继承2份A(基类)的数据成员, 1份来自B, 1份来自C, 2份同名的成员函数拥有不同的域(B和C), 实例化和销毁D时, A会构造和析构2次

# 虚继承

1. B虚继承A, C虚继承A, 使得实例化D时只实例化1次A, 但成员函数无法传入参数
2. B和C虚基类
