# 对象的实例化 Instantiation

1. 从栈中实例化的对象, 由系统自动释放对象, 对象名称使用 "." 操作符访问数据成员和成员函数, 调用默认构造函数时, 不能使用空括号, 因为会将默认构造函数调用误判为函数声明
2. 从堆中实例化的对象, 需要手动释放对象, 对象指针使用 "->" 操作符访问数据成员和成员函数, 由于存在 new 运算符, 不会误判, 则可以有空括号, 当然也可以不写括号

```
class 类名{
	// 数据成员和成员函数
};							// 类的定义

类名 对象名;					// 从栈中实例化对象
类名 对象名[];				// 从栈中实例化对象数组

类名 *ptr = new 对象名();	// 从堆中实例化对象指针
类名 *arr = new 对象名[];	// 从堆中实例化对象数组指针
delete ptr;					// 释放对象
delete []arr;				// 释放对象数组
```

# 对象的初始化 Initialization

1. 注意基本数据类型的初始化只包括复制初始化和直接初始化?
2. 对象的存储结构: 类在实例化前是不占用内存的, 对象实例化后对象的成员数据在堆或栈中分配内存, 成员函数在代码区(正文段)不占用对象的大小, 如果一个对象不存在任何数据成员, 对象实例化后, 则其理论大小应为0, 但为了标记该对象的存在, 为其分配了1个字节的内存, 同类型的对象使用同一个代码区的函数实现代码
3. 对象的初始化: 两种, 有且仅有一次初始化和根据条件初始化
4. 容器的初始化: 可以初始化一个空的容器, 或复制别的容器, 只能用默认构造函数进行初始化, 不能使用自定义构造函数初始化
5. 若编译器的优化级别够高, 且该类具有显式定义的公有的构造函数, 可能会将赋值初始化优化为调用该构造函数的直接初始化, 从而省去创建临时对象的步骤, 但无法对不支持赋值的类，或者使用非显式的构造函数的类做此优化

复制初始化 Copy Initialization (等号形式)

1. 若赋值操作符的右操作数是要初始化的数据成员, 则先调用指定构造函数, 为数据成员创建一个临时对象，然后调用拷贝构造函数将该临时对象复制到正在创建的对象
2. 若赋值操作符的右操作数是已经存在的该类对象, 则由于对象已经存在, 不再需要创建临时对象, 直接调用拷贝构造函数将指定的对象复制到正在创建的对象
3. 总结: 对象的赋值初始化总会调用拷贝构造函数, 因此, 拷贝构造函数必须为公有

直接初始化 Direct Initialization (括号形式)

1. 若构造函数的参数是要初始化的数据成员, 直接调用以数据成员作为参数的构造函数
2. 若构造函数的参数是已经存在的该类对象, 直接调用以对象作为参数的拷贝构造函数
3. 总结: 对象的直接初始化会直接调用与实参匹配的构造函数

列表初始化 List Initialization (大括号形式)

1. 列表初始化将基本类型和复合类型的初始化形式统一起来, 不允许缩窄 (narrowing) (C++ Primer Plus p64)

Aggregate Initialization, Default Initialization, Value Initialization, Reference Initialization, Static non-local Initialization, Dynamic non-local Initialization

# 内存管理

1. 内存是由操作系统控制的资源, 应用程序可以向操作系统申请和归还内存资源, 申请的内存在堆中
2. 申请和释放操作必须配套且成对使用, C++ 使用 new 和 delete 运算符, C 使用 malloc 和 free 运算符
3. 一旦重复调用了 delete, 内存被重复回收, 系统就会出现错误
4. 使用 new 运算符申请内存时, 应使用指针接收申请到的内存地址, 分配失败(内存空间不足)则返回空指针
5. 使用 delete 运算符释放内存(由操作系统回收)后, 应将指针设置为空, 否则该指针还指向已经被释放的那块内存
6. 内存分区: 栈区, 堆区, 全局区, 常量区, 代码区

```
int *ptr = new int(10);		// 整型数据的直接初始化
int *arr = new int[10];		// 申请块内存
*ptr = 10;
arr[0] = 10;
delete ptr;
delete []arr;	// 没有中括号的话则只能释放数组第一个元素的内存
ptr = NULL;
arr = NULL;
```

# 构造函数 constructor

0. 数据成员未初始化时值是随机的
1. 构造函数可以防止忘记调用或多次调用初始化函数
2. 构造函数在对象实例化时被自动调用, 常用于对象的初始化, 因此可将初始化代码写在构造函数中
3. 构造函数名称与类名相同, 访问限定应为公有(否则无法构造子类), 没有返回值(void 也不用写)
4. 构造函数可以重载, 实例化对象时, 仅会用到其中一个
6. 当用户没有定义构造函数时, 编译器自动生成一个默认的构造函数, 函数体为空
7. 在构造函数中申请的内存应在析构函数中释放
8. 在实例化对象时, 即调用了构造函数, 在小括号中写构造函数的参数, 在类内声明的构造函数的参数可以有默认值
9. 实例化对象且不带参数时, 如果有参数的构造函数全部有默认值, 会和无参数的构造函数发生混淆, 即默认构造函数有多个时将无法区分

构造函数的初始化列表

0. 成员函数定义时, 在参数后面, 函数体前, 接冒号后面编写初始化列表来初始化数据成员, 就不用再在构造函数的函数体内初始化数据成员了, 初始化列表的参数可以同构造函数的参数
1. 初始化列表只能用于构造函数, 先于构造函数执行, 即先对数据成员进行初始化, 再调用构造函数
2. 初始化列表可以同时初始化多个数据成员, 效率更高
3. 初始化列表的必要性: 给 const 成员常量赋初始值, 因为 const 常量不能先定义, 后再赋值
4. 构造函数的初始化列表只支持基本数据类型, 不支持数组或结构, 成员初始化的顺序取决于类中成员定义的顺序, 而非初始化列表中的顺序

默认构造函数 default constructor

1. 实例化对象时不需要传递参数的构造函数(无参或参数全都有默认值)称为默认构造函数, 一个类可以没有默认构造函数

拷贝构造函数 copy constructor

1. 当采用直接初始化或复制初始化来实例化对象时(即用一个对象初始化另一个对象会发生拷贝), 系统自动调用拷贝构造函数
2. 在对象作为函数参数传递时(也会发生对象的拷贝), 系统也会自动调用拷贝构造函数
3. 当用户没有定义拷贝构造函数时, 编译器自动生成一个默认的拷贝构造函数
4. 拷贝构造函数的参数确定为某个对象, 因此不能够重载

```
类名(const 类名 &对象名){}	// 拷贝构造函数参数是同类型的对象的引用常量
```

拷贝构造函数中的深拷贝和浅拷贝

1. 浅拷贝就是将原对象的数据成员的值一一赋给通过拷贝实例化的新对象. 但如果对象还包含资源(资源或者一个文件), 原对象和拷贝出的新对象就可以同时对资源可以访问, 即指针指向同一块内存, 会导致销毁对象时, 堆内存被回收两次, 出现运行时错误而崩溃
2. 深拷贝就是把资源也拷贝一次, 使对象拥有不同的资源, 但资源的内容是一样的. 对于堆资源来说, 就是新开辟一片堆内存, 对原来堆中的内容进行拷贝, 因此, 拷贝构造函数中应重新申请内存, 并将指针指向的内容进行拷贝, 而不是拷贝指针本身的内容(地址)
3. 拷贝构造函数的实现可以有深拷贝和浅拷贝, 区别是在对象中包含其它对象成员的引用的时候，当拷贝一个对象时，如果需要拷贝这个对象引用的对象，则是深拷贝，否则是浅拷贝, 深拷贝表示“聚合关系”，浅拷贝表示“相识关系”
4. COW 语义是“深拷贝”与“推迟计算”的组合，仍然是深拷贝，而非浅拷贝，因为拷贝之后的两个对象的数据在逻辑上是不相关的，只是内容相同

# 析构函数

1. 在对象被销毁时(对于栈中对象是在程序返回时或堆中对象调用 delete 销毁对象时)自动调用, 用于释放动态申请的内存资源
2. 析构函数没有返回值, 不允许带任何参数(也即不可重载)
3. 当用户没有定义析构函数时, 编译器自动生成一个默认的析构函数
4. 通过拷贝构造函数实例化的对象在销毁时也会调用析构函数

```
~类名(){}		// 析构函数, 不允许带参数
```
# 数据成员, 成员函数

数据封装 Encapsulation

1. 将数据成员和成员函数封装成一个对象, 数据成员一般以 "m_" 开头, 表示 mine 或 member, 成员函数的参数以 "\_" 开头
2. 使用成员函数来操作数据成员, 而不应直接访问数据成员, 即属性封装函数(set 和 get)
2. 只读属性: 对私有数据成员只有读方法, 没有写方法
4. 同类的不同对象有各自的数据成员(不同的内存), 但调用的是相同的成员函数(同一块代码区)

成员函数的定义

1. 在类内定义: 成员函数的定义(函数体)在类定义的内部, 编译器会优先编译成内联函数
2. 同文件类外定义: 成员函数的声明和定义在同一个文件中, 声明在类内部, 定义在类外部(需要使用域解析操作符指明函数属于某个类)
3. 分文件类外定义: 成员函数在头文件中声明, 在源文件中定义, 源文件需要包含头文件(常用此方式)

函数参数默认值

1. 函数声明时, 可以给参数赋默认值(函数定义时有的编译器可以, 有的不可以), 必须从最右侧参数开始连续的在函数声明(原型)中赋函数参数默认值
2. 函数调用时, 有实参则会采用实参, 无实参则用默认值, 但不能跳过任何实参
3. 默认参数的使用可以减少要定义的析构函数, 方法以及方法重载的数量

内联函数

1. 函数声明时, 使用 inline 关键字声明内联函数
2. 编译时将函数体代码和实参代替函数调用语句, 实参的值直接赋值给形参
3. 内联函数是建议性的, 编译器最终决定如何处理
4. 内联函数适用于逻辑简单(如不包含 for, while 循环), 调用频繁的函数
5. 递归函数无法使用内联函数

函数重载

1. 函数名相同, 参数类型或个数不同(即函数特征标 function signature)不同的函数互为重载, 函数的返回值类型无所谓
2. 编译器内部使用名称修饰(name decoration)跟踪每一个重载函数, 例如编译器使用函数名加参数类型形成新的函数名, 以区分不同函数
3. 互为重载的函数必须在相同作用域(命名空间)内, 或者说在同一个类中
4. 类型引用和类型本身视为同一个特征标, 因为在调用时都是传入变量本身, 无法区分 p277
5. const 参数和常规参数可以互为重载, const 参数可接收 const 和常规实参, 常规形参只接受变量实参

```
int		max(int x, int y)		// 实际名称变为 max_int_int
double	max(double x, double y)	// 实际名称变为 max_double_double
```

# 对象, 对象指针, 对象引用

1. 指向对象的指针, 使用 new 运算符实例化的对象指针指向的是对象的第1个数据成员
2. \*p 表示该对象本身, 可以使用 . 操作符, p 表示对象指针, 使用 -> 操作符访问数据成员
3. 对象指针也可以指向通过栈实例化的对象

对象数组

1. 数组元素类型是对象的数组, 用于存储对象数组的指针可以进行指针运算来指向(访问)数组的各个元素, 释放时, 指针应指向第1个元素
2. 使用 new 实例化对象数组时, 数组中的每个对象元素都要调用一遍构造函数
3. 使用 delete 销毁对象数组时, 数组中的每个对象元素也都会调用一遍析构函数, 如果不使用中括号[], 则只会释放指针当前指向的那个元素, 造成内存泄漏

this 指针

1. this 指针是所在对象内部的对象指针, 用于访问该对象的数据成员, 成员函数体内对象的数据成员和函数参数重名时, 可以显式的将数据成员使用 this 指针标明
2. this 指针在编译时自动被添加为成员函数的第一个参数, 传递到成员函数实现的代码区, 同类的不同对象调用成员函数时, 就可以访问到当前对象的数据成员
3. this 指针用于对象的内部实现, 由编译器自动产生, 而对象指针用于在编写程序逻辑在对象外部使用对象时访问一个对象
4. this 指针是给编译器看的, this 是关键词, 是表达式, 但不是指针变量, 并不是确实存在的对象的数据成员, 而虚函数表指针是对象的数据成员

| 成员函数返回值类型 | 返回代码      | 函数返回值    |
| --------------- | ------------ | ----------- |
| 该对象的本身      | return *this | 临时对象      |
| 该对象的引用      | return *this | 当前对象      |
| 该对象的指针      | return  this | 当前对象的指针 |

# 对象成员, 对象成员指针

1. 对象的数据成员是对象类型
2. 如果对象A中有对象成员B和C, 实例化对象A时会按照对象B, 对象C, 对象A的顺序进行构造, 销毁时顺序相反(ACB), 自动
3. 如果对象A中有对象成员B, 而对象B没有默认构造函数(有参数但没有默认值), 那么对象A必须在初始化列表中初始化对象B(调用对象A的对象成员即对象B的构造函数)

1. 对象的成员是另一个对象的对象指针, 叫做对象成员指针
2. 可以使用初始化列表将其初始化为 NULL 指针或在构造函数中使其指向使用 new 操作符实例化的对象
3. sizeof 对象时, 其大小是所有数据成员的总和, 若成员是对象指针, 则是所有对象成员指针本身大小的总和
4. 在析构函数中销毁对象时, 应销毁对象成员指针指向的对象的内存, 手动

# 常对象, 常对象指针, 常对象引用, 常对象成员, 常成员函数

1. 对象的常指针: 指针指向的对象是常量, 该对象只具有读权限, const 修饰的是 \*p
2. 对象指针常量: 指针只能指向这个对象, 该对象依然是具有读写权限的, const 修饰的是 p
3. 常对象, 对象的常指针或常引用只能调用常成员函数, 因为只读权限的对象不能调用读写权限的成员函数, 不能用小权限调用大权限
4. 普通对象能够调用普通成员函数, 也能调用常成员函数, 大权限可以调用小权限
5. 一个对象可以有多个对象常引用

1. 常数据成员需要用初始化列表进行初始化(普通成员用赋值, 对象成员用构造函数), 不能用数据封装函数赋值, 因为常量必须在定义时初始化

1. 常成员函数声明和定义的后面均加 const 关键字, const 本质上修饰的是成员函数的 this 指针参数
2. 常成员函数中不能修改数据成员的值, 因为此时成员函数的隐含的参数 this 指针变成了常指针, 所以修改常指针指向的数据成员是不合法的
3. 常成员函数和同名的普通成员函数互为重载, 这样的函数调用时, 如果实例化的对象是常对象, 即用 const 修饰, 则调用的是常成员函数, 否则调用普通的同名的成员函数
4. 常成员函数中不能调用普通的成员函数, 可以传入普通的数据成员, 但由于是被常对象调用, 不能改变数据成员的值

# 参考

1. [C++中this指针藏在哪里？](https://www.zhihu.com/question/53724184?sort=created)
