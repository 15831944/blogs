# 1 类和对象

## 1.1 对象的实例化

### 1 从栈中实例化

由系统自动释放对象

使用 . 操作符访问数据成员和成员函数

```
类名 对象名;		// 定义对象
类名 对象名[];	// 定义对象数组
```

### 2 从堆中实例化

需要手动释放对象

使用 -> 操作符访问数据成员和成员函数

```
类名 *pointer = new 对象名();		// 定义对象指针
类名 *pointer = new 对象名[];		// 定义对象数组指针
delete p;
delete []q;
```

# 2 string 类

## 2.1 初始化 string 对象

```
string s1;			// 定义空的字符串对象
string s2("abc");	// 用字符串字面值初始化字符串对象
string s3(s2);		// 将 s3 初始化为 s2 的一个副本
string s4(n,'c');	// 将 s4 初始化为 n 个 字符 'c' 的副本
```

字符串拼接: 两个字面值字符串不可以使用 "+" 进行拼接

# 3 数据封装

数据成员 以字母 m 开头

属性

只读

成员函数(方法)

# 4 类外定义

1. 内联函数: 编译时将函数体代码和实参代替函数调用语句
2. 类内定义: 成员函数定义在类的内部, 编译器会优先编译成内联函数
3. 类外定义: 成员函数定义在类的外部
4. 同文件类外定义: 成员函数的声明和定义在同一个文件中
5. 分文件类外定义: 成员函数在头文件中声明, 在源文件中定义, 源文件需要包含头文件

# 5 构造函数和析构函数

## 1 内存按用途分区

1. 栈区: 定义变量, 指针等, 系统自动回收内存
2. 堆区: 使用 new 定义的对象, 手动管理内存
3. 全局区: 存储全局变量和静态变量
4. 常量区: 存储字符串常量
5. 代码区: 存储二进制逻辑代码

## 2 对象的存储结构

类在实例化前是不占用内存的, 对象实例化后对象的成员数据在栈中分配内存, 成员函数在代码区, 同类型的对象使用同一个代码区的函数实现代码

## 3 对象的初始化

可能有且仅有一次初始化和根据条件初始化

## 4 构造函数

1. 构造函数可以防止忘记调用或多次调用初始化函数
2. 构造函数在对象实例化是被自动调用, 因此可将初始化代码写在构造函数中
3. 构造函数名称与类名相同, 没有返回值(void 也不用写)
4. 构造函数可以有多个重载形式
5. 实例化对象时, 仅用到其中一个构造函数(如果存在多个)
6. 当用户没有定义构造函数时, 编译器自动生成一个默认的构造函数, 函数体为空
7. 构造函数可以无参数或有参数

## 5 默认构造函数

1. 实例化对象后带小括号时, 会调用默认构造函数
2. 实例化对象时不需要传递参数的构造函数称为默认构造函数
3. 无参或参数全都有默认值的构造函数都为默认构造函数

## 6 构造函数的初始化列表

1. 初始化列表先于构造函数执行
2. 初始化列表只能用于构造函数
3. 初始化列表可以同时初始化多个数据成员, 效率更高

初始化列表的必要性: 给 const 常量赋初始值

## 7 拷贝构造函数

```
构造函数名( const 类名 &对象名 ){}	// 构造函数名必须与类名一致
```

1. 当用户没有定义拷贝构造函数时, 编译器自动生成一个默认的拷贝构造函数
2. 当采用直接初始化或复制初始化来实例化对象时(即用一个对象初始化另一个对象会发生拷贝), 系统自动调用拷贝构造函数
3. 在对象作为参数传递时(也会发生对象的拷贝), 系统也会自动调用拷贝构造函数
4. 拷贝构造函数的参数确定为某个对象, 不能够重载

## 8 析构函数

1. 在对象被销毁时(程序返回或调用 delete 销毁对象)自动调用, 用于释放资源
2. 析构函数没有返回值, 不允许带任何参数(也即不可重载)
3. 当用户没有定义析构函数时, 编译器自动生成一个默认的析构函数
4. 通过拷贝构造实例化的对象在销毁时也会调用析构函数

# 参考

1. [C++ 远征之封装篇（上）](http://www.imooc.com/learn/382)
