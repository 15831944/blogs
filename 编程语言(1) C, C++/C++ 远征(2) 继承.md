# 继承 Inheritance

1. 子类(派生类, derived)可以继承父类(基类, base)的数据成员和成员函数, 子类的数据成员在内存中包括自身的和继承自父类的数据成员(与父类的数据成员占用不同的内存空间), 子类的成员函数呢?
2. 实例化子类会先调用父类的构造函数, 再调用自身的构造函数, 销毁子类会先调用自身的析构函数, 再调用父类的析构函数
3. 定义子类时应包含父类的头文件

# 继承方式

本对象数据成员的访问属性

| 访问限定符  | 在类外访问 | 在类内访问 | 是否可被继承 |
| ---------- | -------- | -------- | ---------- |
| public     | 允许      | 允许      | 是         |
| protected  | 禁止      | 允许      | 是         |
| private    | 禁止      | 允许      | 否         |

1. 访问本对象的数据成员的语句的位置可以在类外, 指可以是其他对象的成员函数中, 也可以是全局函数中(客户文件中), 类内是指在该类的成员函数内可以访问该类的数据成员(实现文件中)
2. 禁止访问表明不能用成员访问操作符访问(需要用数据封装函数访问), 允许访问表示可以使用成员访问操作符访问
3. protected 和 private 访问限定符修饰的数据成员在不涉及继承的情况下, 其特性是一致的, 因此保护的含义是对继承进行保护

派生类对基类成员的访问属性

| 继承方式 \ 父类成员访问属性 | public    | protected | private |
| ----------------------- | --------- | --------- | ------- |
| public                  | public    | protected | 不可见   |
| protected               | protected | protected | 不可见   |
| private                 | private   | private   | 不可见   |

1. 公有继承, 父类的公有数据成员和受保护数据成员被继承到子类后, 子类中的数据成员的访问属性不变, 子类可以在该子类的内部和外部允许访问父类的公有成员, 子类在子类内部允许访问父类的受保护成员, 即由对象的创建者和使用者所公有;
2. 保护继承, 父类的公有数据成员和受保护数据成员被继承到子类的受保护数据成员中, 子类在子类内部允许访问父类的公有数据成员和受保护成员, 在子类外部则不能, 即被保护(封装)在类内, 只能由类的创建者使用;
3. 私有继承, 不指明时为默认方式, 父类的公有数据成员和受保护数据成员被继承到子类的私有数据成员中, 子类在子类内部允许访问父类的公有数据成员和受保护成员, 父类的成员在当前子类中变为私有, 无法再被当前子类的子类所继承, 即私有继承的成员到本对象为止;
4. 父类的私有数据成员不允许继承, 父类的私有成员被继承到子类的不可见位置, 即子类不能访问父类的私有成员(但可以调用继承自父类的公有方法间接地访问), 但实际上子类是包含父类的所有数据成员的, 以免子类赋值给父类时发生语法错误

# 继承关系中的隐藏

1. 继承关系的子类和父类中具有同名的(参数可以不同)成员函数时, 子类的成员函数会隐藏继承来的父类的同名成员函数, 使用子类对象直接调用时访问的是子类的成员函数
2. 同名的数据成员同样具有隐藏的特性, 但由于继承来的数据成员本来就独立于父类的数据成员, 且逻辑上继承关系的类之间不应有同名的数据成员, 实际使用价值不大
3. 父类的同名成员函数的确被继承到了子类中, 子类若想访问被隐藏的父类的同名的成员函数, 则使用子类对象调用时应在函数名前指明父类的域, 以使子类访问父类的函数
4. 成员函数的隐藏只要求函数名相同, 参数可以不同, 因此继承来的成员函数和自身的同名的但参数不同的成员函数不能互为重载, 重载是对于同类中的函数而言的, 调用父类函数时还是要指明父类的域, 但不影响父类和子类中分别有各自的互为重载的函数
5. 父类的成员函数虽然被隐藏, 但依然可以访问, 区分成员函数的覆盖
6. 返回类型协变(covariance of return type)

# 有一个的关系(has a)

1. “有”的关系，从属关系, 包含关系，如链表有头结点和中间各节点, 线段有两个坐标点, 电脑有处理器
2. 对象的组合是包含关系, 对象A的私有数据成员有(包含)对象成员B, 则对象A只能访问对象B的公有数据成员, 因为A是在B类外访问B的成员, 只能通过成员访问操作符访问
3. 私有继承也是包含关系, 子类的私有数据成员有(包含)从父类继承而来的父类的公有数据成员和受保护数据成员, 子类只能访问从父类继承的公有数据成员, 同样只能通过成员访问操作符访问

# 是一个的关系(is a)

1. "是"的关系, 表示延续，子类是一个父类, 如士兵是人, 本科生是学生，自行车是交通工具
2. 父类对象在实例化时可以被子类对象赋值(拷贝构造), 因为子类中必定有父类的数据成员, 可继承的成员将对应被赋值, 子类独有的成员将被截断而丢失, 会先构造父类对象(父类私有成员此时会被初始化), 再构造子类对象
3. 父类对象指针或引用作为形参可以接受子类的实参, 因为函数对父类进行的操作, 传入的子类对象都能够提供, 由于是传址调用, 实际被修改的也是传入的子类的继承自父类的那部分数据
4. 父类对象指针可以指向子类对象, 但只能访问到子类继承自父类的成员, 不能访问到子类独有的成员(访问不全)或调用子类的成员函数(即使是公有), 类似小权限可以指向大权限
5. 父类对象指针指向从堆中实例化的子类对象时, 即实例化了一个子类, 但用父类对象指针对其进行访问, 在构造子类对象时, 会先调用父类的构造函数, 再调用子类的构造函数, 是正常的, 但在使用 delete 销毁父类对象时, 由于是用父类指向子类, 只会调用父类的析构函数, 由于子类对象没有被销毁, 会造成内存泄漏, 需将父类的析构函数声明为虚函数(子类的析构函数最好也声明为虚函数)
6. 公有继承和受保护继承是“是”的关系，子类"是一个"父类, 子类可以直接修改(实例化)父类, 子类可以作为实参传给父类, 父类对象指针可以直接操作子类, 只不过只能访问可继承的那部分成员
7. 向上强制转换: 将派生类引用或指针转换为基类引用或指针叫做向上强制转换(upcasting), 是可传递的

基类对象, 对象指针, 对象引用作为函数参数

1. 基类的对象作为函数参数时, 可以传入基类对象或派生类对象, 实际上是传值调用, 会新建一个临时的基类对象(调用基类的拷贝构造函数), 函数返回时销毁这个临时对象(调用基类的析构函数)
2. 基类的对象指针(传入对象的地址)或引用(传入对象本身)作为函数参数时, 实际上是传址调用, 是对象的引用, 不会创建临时对象, 因此效率更高

成员初始化列表

1. 构造子类时, 只能通过成员初始化列表将值传递回相邻的基类的构造函数, 先构造基类, 再构造子类

# 单继承, 多继承

多重(级)继承

1. A派生B, B派生C, 则ABC之间是多重继承, 如果是公有继承, 则B是一个A, C是一个B, C是一个A, 即直接或间接子类都是 is a 的关系
2. 实例化继承链中最底层的子类时, 会从基类到派生类一级一级的构造, 销毁时顺序相反

多继承 MI

1. 一个子类有多个父类, A 和 B 都是 C 的父类, 如果均是公有继承(每个父类的类名前都要写 public), 则 C 是一个 A, C 是一个 B, 例如农民工的父类是农民类和工人类
2. 实例化子类时, 会按照初始化列表的顺序依次调用多个父类的构造函数, 后调用子类的构造函数, 销毁时顺序相反

菱形继承

1. B和C继承A, D继承B和C, ABD和ACD为多重继承, BCD为多继承
2. D(底层)中会继承2份A(基类)的数据成员, 1份来自B, 1份来自C, 产生数据的冗余增加系统开销, 2份同名的成员函数拥有不同的域(B和C), 实例化和销毁D时, A会构造和析构2次

虚继承

1. B虚继承A, C虚继承A, 则B和C为虚基类, D多继承B和C, A需要声明虚析构函数, 实例化D时只会实例化1次A, D只含有一份A的数据, 并只会获得A的数据, 无法通过D的函数的参数传入并初始化这个数据
