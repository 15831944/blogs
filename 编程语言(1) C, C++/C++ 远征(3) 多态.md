# 多态

1. 多态的定义: 相同对象收到不同消息时(早绑定)或不同对象收到相同消息(调用同名函数)时(晚绑定)产生不同的动作叫做多态
2. 多态的语义: 多态是对于继承关系中的基类和派生类而言的, 使用父类指针指向各个子类对象, 并通过父类指针调用该子类的同名的虚成员函数, 基类对象作为函数的形参时, 可以接受任何派生类对象

函数名联编

1. 将代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)

1. 静态多态(早绑定): 对于一个类中互为重载的函数, 在编译阶段, 编译器就已经可以确定要调用哪个函数了, 叫做早绑定
2. 动态多态(晚绑定): 对于虚成员函数或虚析构函数, 在运行阶段, 使用基类对象指针解决派生类对象的成员函数的访问和派生类对象的资源释放问题, 属于动态多态

1. 使用"游戏角色"这个基类作为形参, 则可以传入各"职业角色"这些子类, 以相同的操作(例如掉血)对各个不同的派生类做不同的处理了
2. 定义"异常"这个接口类, 并作为 catch 的参数, 异常处理就可以是各子类的异常处理成员函数了

# 虚函数

1. 虚函数表: 每个类只有一份虚函数表, 该类的所有对象共用此虚函数表, 该类自身的所有虚函数和继承自父类的虚函数被统一规划到此虚函数表中, 表的元素类型是函数指针, 内容是虚函数的入口地址, 父类和子类有各自的虚函数表, 若两者没有同名的虚函数, 则子类会在与父类虚函数表相同偏移位置指向继承来的父类的虚成员函数, 对于同名的虚函数, 子类会在相同的偏移位置覆盖父类的同名的虚函数的地址, 以保证查找到正确的函数
2. 虚函数表指针: 具有虚函数的基类在实例化后, 第一个公有数据成员就是虚函数表指针 vftable_ptr, 指向自身类的虚函数表, 子类会继承这个虚函数表指针成员并指向子类的虚函数表, 因此父类指针指向子类对象时才能访问到子类的虚函数指针这个成员, 进而以相同的偏移位置访问到子类的同名虚函数

1. 虚函数的声明: 使用 vitrual 关键字修饰继承关系中基类中的成员函数, 则派生类中同名的成员函数也会变成虚函数(也可以使用 virtual 关键字以便于阅读), 即基类的虚函数会延续到各级子类, 这样就建立起继承关系中多个类之间的多态关系
2. 虚函数的本质: 虚函数是成员函数的一份拷贝, 是同名但独立的实体, 会造成资源开销, 继承关系的各类的同名函数本身是不同的实体, 但在调用时, 同一时刻又只可能调用到其中一个, 虚函数与普通成员函数的区别在于虚函数会从虚函数指针指向的虚函数表中查找, 普通成员函数则直接由对象进行查找
3. 虚函数的限制: 只有类的成员函数和析构函数可以是虚函数, 虚成员函数需要同名同参才会发生覆盖, 继承关系的不同类的虚析构函数名同类名, 彼此之间不用同名也会在相同偏移位置发生覆盖, 虚函数应该是公有的成员函数, 否则无法被继承

1. 虚成员函数: 使得基类对象指针指向子类对象时, 调用子类的成员函数
2. 虚析构函数: 使用 delete 销毁基类指针指向的子类对象时, 调用子类的析构函数, 以释放子类资源防止内存泄漏

其他类型函数不能是虚函数的原因

1. 内联函数: 内联函数并非真正可调用的函数实体, 若将内联函数声明为虚函数, 编译器会将该函数强制变成虚函数
2. 静态成员函数: 静态成员函数不属于任何具体的对象, 而是和类同存的, 一个类的所有对象都只能访问这一个静态成员函数
3. 构造函数: 构造子类时原本就必须先构造父类
4. 全局函数: 与类和对象无关

函数的重载, 隐藏, 覆盖

1. 函数的重载: 对于同一个类中的函数(同名不同参且virtual关键字可有可无), 在编译阶段即确定为不同的函数
2. 函数的隐藏: 对于继承关系的不同类的成员函数(同名不同参或同名同参无virtual关键字), 子类的成员函数会隐藏父类的同名成员函数
3. 函数的覆盖: 对于继承关系的不同类的虚函数(同名同参且有virtual关键字), 子类的虚函数会覆盖子类的虚函数表中的父类的同名虚函数

# 纯虚函数

1. 只有声明没有实现的虚函数为纯虚函数(抽象方法), 即没有函数体, 纯虚函数也必须是成员函数
2. 虚函数声明后面写 "=0"即为纯虚函数, 表示虚函数表中纯虚函数指针的为空指针, 也即存放的该虚函数的地址为0

抽象类

1. 至少含有一个纯虚函数(可含有数据成员)的类叫做抽象类, 由于纯虚函数没有实现, 即无法调用, 因此抽象类不允许实例化对象, 只能被继承
2. 抽象类的子类也可以是抽象类, 其子类直到把继承的抽象类的纯虚函数都实现, 该子类才能被实例化对象
3. 抽象类会增加虚函数表, 使对象的体积翻倍, 甚至降低可移植性, 一般只有基类会声明为抽象类, 基类必须要有一个虚析构函数

接口类

1. 只含有纯虚函数(没有数据成员)的类叫做接口类, 没有任何实现, 可以用来表达能力或协议, 其定义一般只需要头文件, 不需要源文件
2. 一个可实例化的子类多继承子一个抽象类和一个接口类, 意味着实现了抽象类的部分功能以及接口类的全部功能
3. 接口类是抽象类

# 运行时类型识别 RTTI

1. 运行时类型识别(run-time type identification)用于在程序运行时识别出父类指针指向的是哪个子类对象
2. 对象内省(typeid): 对 typeid(\*obj) 传入对象类型(不能是对象指针), 返回一个 type_info 对象的引用, 对数据对象进行内省, 如果想要通过基类指针获得子类的类型, 基类必须是抽象类, 否则只能返回基类的数据类型
3. 动态类型转换(dynamic_cast): 动态类型转换只能用于对象的指针或引用的转换(不能是对象本身), 要转换的和被转换的类型中, 必须包含虚函数, 即必须是多态类型, 如果转换成功, 则返回子类的地址, 否则返回 NULL

```
class type_info {
public:
	const char	*name() const;							// 数据类型名称
	bool		operator==(const type_info&rhs) const;	// 操作符重载
	bool		operator!=(const type_info&rhs) const;
	int			before(const type_info&rhs) const;
	virtual		~type_info();
private:
	...
}
```

# 异常 exception

1. 异常: 指运行时错误
2. 常见异常: 内存不足(CMemoryException, 一般由于内存泄漏造成), 文件读写错误(CFileException), 网线未插, 数组下标越界, 除数为0
3. 异常处理: 对有可能发生异常的地方做出预见性的安排, 未处理的异常会被抛给系统, 系统会杀死该进程
4. 异常传播: 异常传播方向与函数调用方向相反, 异常不断向上层调用者抛出, 交由其处理, 如果所有调用函数都无法处理, 最终就会被抛给系统
5. 异常和多态: 使用 throw 抛出子类, 并用以父类对象作为参数的 catch 进行处理, 就可以对各种异常通过父类指针调用各子类的虚函数分别处理

异常的捕获

1. 使用 `try{throw obj} catch(int &i){  } catch(...){  }` 尝试捕获异常, 实现主逻辑与异常处理逻辑分离
2. try 表示尝试运行主逻辑, 主逻辑中使用 throw 表示抛出各种异常, 则主逻辑不再继续运行, 多个 catch 表示捕获相应异常进行异常处理
3. throw 抛出的异常的类型应和 catch 的参数类型对应, catch 的参数是 ... 时, 表示可以捕获任意异常, 一般用于前面都处理不了的默认处理情况
4. catch 既可以获取异常的类型, 也可以获取异常的值, 可以是错误编号, 也可以是对象
