# 友元函数, 友元类

1. 友元函数, 就是可以通过传入被友元类(原始类)的对象, 在函数中(被友元的类外)直接访问被友元的类的受保护和私有的数据成员和成员函数(公有成员本身就可在类外访问)
2. 友元全局函数, 函数参数是被友元的类的对象指针或引用, 除了自身的声明和定义外, 还要在被友元的类的定义中使用 friend 关键字声明是该类的友元函数, 这样就可以在本函数中, 被友元类外, 访问该对象的私有数据成员了
3. 友元成员函数, 在被友元的类中进行函数声明时, 应使用本函数所属的类名和域操作符指明友元成员函数所属的类, 通过参数传入被友元的类的对象, 不能在函数体中定义被友元的对象?
4. 友元类: 在被友元的类中使用 friend 关键字声明该类的友元类, 成员函数参数可以是被友元的类的对象指针或引用, 在友元类的实现中可以定义被友元的类的对象并直接访问被友元的类的受保护和私有的数据成员和成员函数, 被友元类意味着其私有成员会被暴露在外

1. 友元关系不可传递, A是B的友元, B是C的友元, 不代表A是C的友元, 即A可以访问B, B可以访问C, 但A不能访问C
2. 友元关系具有单向性, A是B的友元, 不代表B是A的友元, 即A可以访问C, 但B不能访问A, 即被友元的类定向的把自己的成员暴露给其友元
3. 友元声明的形式(友元函数还是友元类)和数量不受限制, 友元函数和友元类破坏被友元的类的封装性, 因此在功能上应视作对封装的补充, 只有在使用封装特性无法达到目的时才会使用友元的方式

# 静态数据成员, 静态成员函数

1. 静态数据成员依赖于类而不依赖于具体对象, 是全局的, 与对象无关的, 随类的产生而产生, 即若不实例化该类对象, 该类的静态数据成员也存在于内存中
2. 一个类只有一个该静态数据成员的实体, 不算入一个具体对象的大小, 不会在实例化对象时在其构造函数中初始化, 而是需要在类外单独的初始化
3. 在具体对象的成员函数中访问静态数据成员不存在隐式的 this 指针, 每个对象都可以访问这个静态数据成员

1. 静态成员函数中不能访问普通数据成员, 前者随类的产生而产生, 后者随对象的实例化而产生, 访问时可能还未实例化对象
2. 静态成员函数中不能调用普通成员函数, 前者不会隐式的传入 this 指针, 就不知道调用的普通数据成员属于哪个对象, 后者需要传入具体的对象
3. 静态成员函数和普通成员函数中均可以访问静态数据成员和调用静态成员函数, 因为静态数据成员和静态成员函数都是全局的
4. 静态成员函数不能使用 const 修饰, 因为 const 本质上修饰的是 this 指针, 而静态成员函数中没有 this 指针

1. 使用 static 关键字声明静态数据成员和成员函数, 可以通过"类名::函数名"(该类没有实例化对象时)或"对象名.函数名"这两种方式对静态数据成员和静态成员函数进行访问

# 操作符重载

1. 操作符重载: 同一操作符对于不同数据类型的操作数可以进行不同的操作, 叫做运算符重载, 其本质是函数重载, 可以把操作符当做函数名, 操作数当作函数参数
2. C 中的操作符本身就已经实现了函数重载, 例如"=="操作符既可以判断整型数据也可以判断浮点型数据
3. 域解析操作符"::", 成员操作符".", 条件操作符, sizeof, 共4个操作符不允许重载

重载方式

1. 操作符的成员函数重载, 在内类进行操作符重载, 只能用该对象调用重载的操作符, 返回该类对象或其的引用, 含有该对象的隐式的 this 指针参数作为操作数, 因此一元操作符的重载不需要传入参数(操作数就是调用这个操作符的对象或者说 this 指针), 二元操作符须传入一个参数作为第二个操作数, 而 this 指针就是第一个操作数
2. 操作符的友元全局函数重载, 在被友元类内声明友元函数, 操作符不属于任何类, 调用时对象实际是函数参数, 返回值和参数都是被友元类的引用, 并返回这个参数, 不含 this 指针参数, 因此一元操作符的重载需要在参数中传入被友元类的对象作为操作符的各操作数, 二元操作符须传入两个参数分别作为两个操作数
3. 操作符重载方式比较: 成员函数重载必须传入this指针, 友元函数重载则把操作数均作为参数传入, 结果一致但过程不同, 且有些运算符只适用于两种方式中的其中一种

一元运算符的重载

1. 前置自增(自减)操作符, 先增后赋，实现为先做自增，再返回自增后的操作数对象的引用
2. 后置自增(自减)操作符, 先赋后增，实现为先把操作数对象拷贝给临时对象，再操作数自增, 再返回临时对象本身, 为了与前置区分，需多一个整型参数, 但只做区分作用, 没有实际意义, 调用时自动传入0

二元运算符的重载

1. << 输出运算符, 要求函数返回值和第1个参数必须是 ostream 类的对象的引用, 只能通过友元函数进行重载, 因为成员函数重载的第一个参数必须是 this 指针
2. [] 索引运算符, 要求第1个参数必须是 this 指针, 才能传入它的索引, 只能通过成员函数进行重载, 因为友元函数中不存在 this 指针

# 模板函数, 模板类, 泛型编程

1. 函数模板: 用于定义多个功能相同但数据类型不同的函数, 函数模板本身不会在内存中产生代码, 因为没有模板参数指定类型就无从知道要合成怎样的模板函数
2. 模板函数: 通过函数模板生成的各个函数实体叫做模板函数, 是独立的实际的函数, 不包含任何模板, 调用时使用模板参数指定类型, 如果不写方括号则可根据实参类型自动判断
3. 模板参数: 函数模板的思想是将类型作为参数传入, 模板参数可以是类型, 变量(编译生成模板函数时实际上是常量), 或多个类型和变量的组合, 不能是0个, 写在尖括号中
4. 函数重载: 由同一个函数模板生成的不同的模板函数之间互为重载, 来自不同函数模板的函数名称相同但模板参数或函数参数不同的模板函数之间也可以互为重载

1. 类模板: 类模板的定义和其成员函数的定义必须写在同一个头文件中, 类模板的每个成员函数的定义的上一行都要写明模板参数
2. 模板类: 模板类是已经实例化的具体的类, 使用模板类调用成员函数时不用再写模板参数

1. 成员模板

模板的具体化 specialization

1. 隐式实例化 implicit instantiation, 声明并构建一个具体的对象时, 编译器才会使用类模板隐式地生成该类的定义
2. 显式实例化 explicit instantiation, 使用 template 关键字, 不需要创建该类的对象, 来显式地生成该类的定义
3. 显式具体化 explicit specialization,
4. 部分具体化 partial specialization,

```
template<typename T, typename C, int i>			// 模板参数
T max(T a, C b) {								// 函数模板
	int c = i;									// 传入的模板参数是变量时会变成常量
}
char	cVal = max<char, char>('A', 'B', 1);	// 模板函数
```

# 标准模板库 STL

1. 标准模板类库(standard template library)被集成在 IDE 环境中
2. 模板类的名字一般就是该类的头文件的名字，首字母一般为小写
3. 模板类的成员函数都是模板函数？

1. 显式具体化(explicit specialization)： 优先级依次为，非模板函数, 显示具体化模板函数, 常规模板函数

1. 隐式实例化(implicit instantiation): 编译器使用模板为特定类型生成函数定义时, 得到的是模板实例(instantiation), 即函数定义
2. 显式实例化(explicit instantiation): 命令编译器直接创建特定的实例
