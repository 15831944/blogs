#include <stdio.h>

/*******************************************************************
	十进制数	原码						2的补码
	+7			0111
	+6			0110
	+5			0101
	+4			0100
	+3			0011
	+2			0010
	+1			0001
	+0			0000

	-0			1000
	-1			1001	1000,0001		1111	1111,1111
	-2			1010	1000,0010		1110	1111,1110
	-3			1011	1000,0011		1101	1111,1101
	-4			1100	1000,0100		1100	1111,1100
	-5			1101	1000,0101		1011	1111,1011
	-6			1110	1000,0110		1010	1111,1010
	-7			1111	1000,0111		1001	1111,1001
	-8			n.a.	1000,1000		1000	1111,1000

	不论是正数还是负数, 补码使得数字从小到大均是升序, 尽最高位不同, 因此补码可以在硬件层面上统一加减法运算
	-7和+1分别是正数和负数范围中第二小的数, 二者的补码仅差在符号位, -8 ~ -1 对应着 +0 ~ +7
	原码到补码或补码到原码都是非符号位取反加1, 即对二进制的每一位取反加1再取反再加1后和原数相同, 为什么会这样
	最大值+7加1溢出变成最小值-8, -8减1同理, 即补码在整个值域中是连续的
	不要把补码当成数, 而是当成一个范围, 则补码是连续累加的, 形成一个圆环的
	无符号数的加减法为什么不用想办法统一起来?因此 int 算的比 unsigned in 快?
*******************************************************************/

int main()
{
	int			a = -2147483648;
	int			b = -6;
	int			c = 16384;		//2^14
	int			d = 2147483647;	//2^31-1
	int			e;
	long long	l;

	l = d + 1;
	e = d + 1;

	printf("%d %d %d %d\n", sizeof(short), sizeof(int), sizeof(long), sizeof(long long));
	printf("a = %x, b = %x, c = %x, d = %x\n", a, b, c, d);
	printf("l = %lld %llx e = %d %x\n", l, l, e, e);		// l不论是否截掉高16位,值都等于e
}
