# 1. **ELF 文件**

## 1. **种类**

1. 可重定位文件 relocatable file: 用户目标文件和其他目标文件，例如 *.o 或 lib*.a 文件。他们一起用于创建可执行文件或者共享目标文件。  

2. 可执行文件 executable file：用于生成程序映像，载入内存执行，例如编译好的可执行文件 a.out。  

3. 共享目标文件：用于和其他共享目标文件或者可重定位文件一起生成 elf 目标文件或者和执行文件一起创建进程映像，例如lib*.so文件。  

## 2. **作用**

ELF文件参与程序的连接(建立一个程序)和程序的执行(运行一个程序)，所以可以从不同的角度来看待 elf 格式的文件：

1. 如果用于编译和链接（可重定位文件），则编译器和链接器将把 elf 文件看作是节头表 section-headers 描述的节的集合，程序头表 program-headers 可选。
 
2. 如果用于加载执行（可执行文件），则加载器则将把 elf 文件看作是程序头表描述的段的集合，一个段可能包含多个节，节头表可选。  

3. 如果是共享目标文件，则两者都含有。  

## 3. **总体组成**

elf 文件头 file-header 描述 elf 文件的总体信息。包括：系统相关，类型相关，加载相关，链接相关。  

1. 系统相关：elf 文件标识的魔术数，以及硬件和平台等相关信息，增加了elf文件的移植性,使交叉编译成为可能。  

2. 类型相关: 就是前面说的那个类型， 可重定向文件、可执行文件或共享目标文件。  

3. 加载相关：程序头表的相关信息。  

4. 链接相关：节头表的相关信息。 

# 2. **ELF 文件信息查看**

用readelf -S 或 objdump -h 查看段表

用readelf -s 或 objdump -t 查看符号表

使用 size 命令查看各段大小

| 表 | 选项 | 内容 |
| - | - | - |
| 程序头表(段表) | -l --program-headers --segments | 显示程序头（段头）信息，例如记录bss段的大小，即所有未初始化的变量的总大小 |
| 节头表 | -S --section-headers --sections | 显示节头信息，例如记录bss段中每个未初始化的变量的大小 |
| 符号表 | -s --syms --symbols | 显示符号表段中的项 |

# 3. **存储空间布局**

从上到下为高地址到低地址方向，只有 data 段和 text 段是存储在磁盘镜像文件中的。

| 段 | 含义 |
| - | - |
| 命令行参数和环境变量(环境表和环境字符串) | argument and environment | 
| 栈 | stack | 
| 堆 | heap | 
| 未初始化数据段 | bss |
| 初始化数据段 | data | 
| 正文段 | text |

## 1. 命令行参数和环境变量 argument and environment

使程序了解进程环境，在执行时分配内存，调用 exec 函数的进程将命令行参数传递给该新程序，在 shell 中执行某个程序时，shell 进程调用 exec 函数将命令行参数传递给要执行程序，要执行的程序是 是 shell 的子进程。

## 2. 栈 stack

存储自动变量，调用者信息, 包括函数参数（可变参数列表的压栈方向是从右向左）, 函数内局部变量, 函数返回值, 函数调用时的返回地址。执行时，即执行流执行到函数调用时分配内存。高地址是栈底, 向低地址方向增长。

## 3. 堆 heap

用于动态分配的内存，执行时分配内存，例如执行到调用 malloc 函数或 new 函数手动分配内存时。

## 4. bss 段

含义是 Block Started by Symbol, 即符号开始的内存块，未初始化的数据可能是未初始化的全局变量，全局数组，静态变量，指针变量等，bss 段并不占用可执行程序的镜像的空间，而是在执行时分配内存，并由 exec 函数初始化为0，例如声明全局数组 int array[100], 不会将100个0记录在可执行文件镜像中，而只是记录了标识符a和其所占用的内存大小，变量的大小记录在符号表中，要分配的整个 bss 段的大小记录在 段表，即 Section headers 中。

## 5. data 段

具有明确初始值的全局变量和静态变量，存在于程序镜像文件中，由 exec 函数从程序镜像文件中读入内存。

## 6. text 段

CPU 执行的机器指令，父进程和子进程之间可共享正文段，存在于程序镜像文件中且只读，由 exec 函数从程序镜像文件中读入内存，例如在 shell 中正在执行的程序运行正文段的指令。

# 4. **堆和栈的辨析**

堆(heap)和栈(stack)都是基本的数据结构。 

## 1. 栈的底层实现

在具体的C/C++编程框架中，这两个概念并不是并行的。

对底层机器代码的研究可以揭示，栈是机器系统提供的数据结构，而堆则是C/C++函数库提供的。 

具体地说，现代计算机(串行执行机制)，都直接在代码底层支持栈的数据结构。

这体现在，有专门的寄存器指向栈所在的地址，有专门的机器指令完成数据入栈出栈的操作。 

这种机制的特点是效率高，支持的数据有限，一般是整数，指针，浮点数等系统直接支持的数据类型，并不直接支持其他的数据结构。

因为栈的这种特点，对栈的使用在程序中是非常频繁的。

对子程序的调用就是直接利用栈完成的。

机器的call指令里隐含了把返回地址推入栈，然后跳转至子程序地址的操作

子程序中的ret指令则隐含从堆栈中弹出返回地址并跳转之的操作。

C/C++中的自动变量是直接利用栈的例子，这也就是为什么当函数返回时，该函数的自动变量自动失效的原因。 

## 2. 堆的底层实现

和栈不同，堆的数据结构并不是由系统(无论是机器系统还是操作系统)支持的，而是由函数库提供的。
 
基本的malloc/realloc/free函数维护了一套内部的堆数据结构。

当程序使用这些函数去获得新的内存空间时，这套函数首先试图从内部堆中寻找可用的内存空间，如果没有可以使用的内存空间，则试图利用系统调用来动态增加程序数据段的内存大小，新分配得到的空间首先被组织进内部堆中去，然后再以 
适当的形式返回给调用者。

当程序释放分配的内存空间时，这片内存空间被返回内部堆结构中，可能会被适当的处理(比如和其他空闲空间合并成更大的空闲空间)，以更适合下一次内存分配申请。

这套复杂的分配机制实际上相当于一个内存分配的缓冲池(Cache)，使用这套机制有如下若干原因： 

1. 系统调用可能不支持任意大小的内存分配。有些系统的系统调用只支持固定大小及其倍数的内存请求(按页分配)；这样的话对于大量的小内存分类来说会造成浪费。 

2. 系统调用申请内存可能是代价昂贵的。系统调用可能涉及用户态和核心态的转换。 

3. 没有管理的内存分配在大量复杂内存的分配释放操作下很容易造成内存碎片。 

## 3. 堆和栈的特点

从以上知识可知，栈是系统提供的功能，特点是快速高效，缺点是有限制，数据不灵活；

而堆是函数库提供的功能，特点是灵活方便，数据适应面广泛，但是效率有一定降低。

栈是系统数据结构，对于进程/线程是唯一的；

堆是函数库内部数据结构，不一定唯一。

不同堆分配的内存无法互相操作。

栈空间分静态分配和动态分配两种。

静态分配是编译器完成的，比如自动变量(auto)的分配。

动态分配由 alloca 函数完成。

栈的动态分配无需释放(是自动的)，也就没有释放函数。

为可移植的程序起见，栈的动态分配操作是不被鼓励的！

堆空间的分配总是动态的，虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存/释放内存匹配是良好程序的基本要素。 

还有就是函数调用时会在栈上有一系列的保留现场及传递参数的操作。 

栈的空间大小有限定，vc 的缺省是2M。

栈不够用的情况一般是程序中分配了大量数组和递归函数层次太深。

有一点必须知道，当一个函数调用完返回后它会释放该函数中所有的栈空间。

栈是由编译器自动管理的，不需人工管理。
 
堆是动态分配内存的，并且你可以分配使用很大的内存。但是用不好会产生内存泄漏。 

并且频繁地malloc和free会产生内存碎片（有点类似磁盘碎片），因为c分配动态内存时是寻找匹配的内存的。

而用栈则不会产生碎片。 

在栈上存取数据比通过指针在堆上存取数据快些。 

一般大家说的堆栈和栈是一样的，就是栈(stack)，而说堆时才是堆heap. 

栈是先入后出的，一般是由高地址向低地址生长。 

# 5. **堆和栈的区别**

## 1. 堆栈空间分配区别

1. 栈（操作系统）：由操作系统根据变量大小自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；栈内存区的地址是连续的，由系统控制速度较快

2. 堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，也可能发生内存泄露，分配方式倒是类似于链表。堆内存区的地址是不连续的，它是系统将空闲内存块链接起来的链表，用户用new/malloc请求分配时，找到第一个满足大小要求的块从链表中删除此节点，然后分给用户，没有栈内存速度快，但是很灵活。

## 2. 堆栈缓存方式区别

1. 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；

2. 堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得慢一些。

## 3. 堆栈数据结构区别

1. 堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

2. 栈（数据结构）：一种先进后出的数据结构。

# 6. 举例

```
int a = 0; //全局初始化区 
char *p1; //全局未初始化区 
main() 
{
int b; //栈 
char s[] = "abc"; //栈 
char *p2; //栈 
char *p3 = "123456"; //123456\0在常量区，p3在栈上。 
static int c = 0； //全局（静态）初始化区 
p1 = (char *)malloc(10); 
p2 = (char *)malloc(20); 
//分配得来得10和20字节的区域就在堆区。 
strcpy(p1, "123456"); 
//123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一块。 
} 
```
# 7. 参考

[readelf命令](http://man.linuxde.net/readelf)
[面试官问我：bss段的大小记录在哪里？](http://bbs.csdn.net/topics/390613528)
