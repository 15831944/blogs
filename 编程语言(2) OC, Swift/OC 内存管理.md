# 对象的生命周期

1. 对象的生命周期: 对象可以被创建(分配内存和初始化), 拷贝, 保持, 归档, 释放(release), 销毁(dealloc), 程序终止会释放所有对象
2. 对象的保持数: 一个 Cocoa 对象被创建后, 其他对象向它发送消息, 需要关心该对象的持久性, 即对象的保持数, 保持数是每个 Cocoa 对象都具有的一个隐藏的实例变量
3. 对象的创建: 对象的 isa 指针指向对象的类, 将对象集成到类层次的运行时视图中, 对象的保持数设置为1(假定对象的创建者关心其持久性)
4. 对象的释放: 向对象发送 release 消息时, NSObject 会减少它的保持数, 如果保持数从1下降到0, 系统会自动调用 dealloc 方法(不可人工调用)销毁对象, 释放对象的实例变量和动态分配内存
5. 对象的保持: 向对象发送 retain 消息, NSObject 会增加它的保持数, 对象的创建者发消息将对象传递给客户对象, 该对象在客户对象的作用域内总是正当的, 客户对象可以向该对象发送消息或将其传递给其他对象. 对象的发送者(这里即对象的创建者)不应在客户对象仍然拥有该对象的引用时将它过早释放. 对象的创建者不需要保持该对象, 但客户对象需要保持该对象. 向对象发送 retain 消息, 表示希望拥有该对象, 并有责任释放该对象. 子对象不能保持它的父对象以避免循环引用(父对象是该子对象的创建者，或者将该子对象作为实例变量持有的对象)
6. 对象的拷贝: 多数子类都封装了某种数据采纳方法, 或遵循这种协议, 拷贝不仅对对象进行复制, 而且将拷贝而来的对象的保持数设置为1, 客户对象对拷贝过来的对象是新的且唯一的拥有者, 可以修改该对象而无须考虑其原始对象, 对于可变的值对象, 一般进行拷贝而非保持, 对于不可变对象, 拷贝和保持等价, 其实现方法也类似

# 对象的所有权策略 Ownership Policy

对象的所有权策略决定了如何使用对象的管理机制, 对象的引用具有对象的所有权

1. 创建对象: 拥有该对象, 需要负责该对象的释放, 自动计数时应使用强引用, 对象至少要有一个强引用防止对象被过早释放
2. 拷贝对象: 拥有拷贝的对象，需要负责该拷贝的对象的释放
3. 保持对象: 部分拥有该对象, 需要在不再使用时释放该对象, 自动计数时应使用弱引用
4. 接收对象: 不拥有该对象, 通过参数传递来引用, 不应该释放它(有少数例外)

对象所有权策略的例外

1. 通过类工厂方法创建并接收的对象可假定已经被放到自动释放池中, 不应人工释放, 如果需要保持该对象, 则应调用 retain 方法, 如 NSMutableArray arrayWithCapacity:

对象所有权策略解决的问题

1. 内存泄漏: 自己创建, 拷贝, 保持的对象没有释放(release)会导致内存泄露
2. 悬挂指针: 对象的创建者并不知道何时可以安全地释放对象, 因为在调用堆栈中可能存在多个来自创建者不知道的对象对该对象的引用, 如果对象的创建者释放了该对象, 对象的引用称即成为悬挂指针(dangling), 给悬挂指针发任意消息(如 release)会触发运行时错误

# 内存管理机制

1. 内存管理策略包括: 系统自动追踪对象, 需要时自动释放对象, 二者混合方式
2. 内存管理机制包括: 自动垃圾收集, 手工引用计数和自动释放池, 自动引用计数
3. 自动垃圾收集: 系统自动检测对象是否拥有其他对象, 当程序执行需要空间时, 不再被引用的对象会被自动释放(垃圾回收), iOS 不支持且 OS X 不推荐此机制
4. 引用计数: 系统使用一个主动的策略驱动的例程来保持对象, 并在不再需要的时候进行清理, 调用框架中的一些方法(add, remove 开头)会修改引用计数(增加或释放对象的引用)


# 手工引用计数和自动释放池

解决问题

在方法中分配和返回对象: 在自定义的方法中创建一个对象并返回该对象会导致创建一个对象的方法在不再使用该对象时却不能释放它, 可在创建或返回该对象时, 向其发送 autorelease 消息进行追踪

自动释放池的定义

自动释放池是一种延迟释放对象机制, 追踪一个以 `@autoreleasepool` 指令显式定义的作用域内的对象集合, 该作用域内的对象被标志为延迟释放, 对象必须是来自 Foundation, UIKit, AppKit 框架的类实例, 程序执行到 autorelease 块末尾时, 系统会发送 release 消息释放被追踪的对象, 若这些对象的引用计数为0, 则会发出 dealloc 消息销毁对象, 释放其内存, 对于程序使用或不使用 ARC 进行编译的情形均适用, 可以在自动释放池中嵌套小的自动释放池来销毁临时产生的大量临时对象

自动释放池的使用

Cocoa 程序运行在一个事件循环中, 事件是伴随着某些行为(按下按钮)或隐性行为(网络请求)发生的, 系统会创建一个新的自动释放池来处理一个新事件, 可能会调用一些方法, 处理完后, 从方法中返回, 并等待下一个事件的发生, 事件处理完成前, 系统会清理新创建的自动释放池, 释放事件处理过程中创建的对象, Application Kit 会在未启用 ARC 特性的项目会在生成的模板文件的 main 函数起始位置自动添加自动释放池, 定义自动释放池的块, 其作用域为为应用程序的事件周期

手工引用计数方法

在未启用 ARC 时才会调用以下方法

1. autorelease 消息: 给对象发送 autorelease 消息, 可将对象添加到由自动释放池维护的对象列表中, 不包含实际的对象, 而是对象的引用, 不会影响该对象的引用计数, 向一个对象发送 autorelease 消息时, Cocoa 会将该对象的一个引用放入到最新的自动释放池. 它仍然是个正当的对象, 自动释放池定义的作用域内的其它对象可以向它发送消息. 当程序执行到自动释放池作用域结束位置时, 自动释放池就会被释放, 池中的所有对象也就被释放.
2. release 消息: 会使引用计数减1
3. retain 消息: 会使引用计数加1, 使用了 retain 方法的对象会在清理自动释放池后幸存, 需要在事件循环结束后手动清理, 需要覆写 dealloc 方法, 先释放幸存的对象, 再释放父类
5. alloc, init, copy, mutableCopy, new 为前缀的方法返回对象的所有者给方法的调用者, 调用者创建并拥有的对象(来自框架的和自定义的对象), 会使引用计数初始化为1, 需要人工释放其内存
6. retainCount 消息: 返回对当前的保持次数
7. dealloc 消息: 由需要释放对象的实例变量以及释放动态分配的内存的类实现

```
#import <UIKit/UIKit.h>
@interface myView : UIView
@property (nonatomic, retain) NSMutableArray *data;
@end

- (void)viewDidLoad {
	data = [NSMutableArray array];				// 创建一个自动释放的数组, 当前事件结束后会立即销毁
	data = [[NSMutableArray array] retain];		// 当事件结束后, 将从释放池中幸存
	data = [[NSMutableArray alloc] init];		// 创建一个不会自动释放的数组
	self.data = [NSMutableArray array];			// 使用设值方法, 保持已赋值给具有 retain 特性的属性的任何对象
}

- (void)dealloc {
	[data release];
	[super dealloc];
}
```

# 自动引用计数 ARC

1. 系统会检测出何时需要保持对象, 自动释放对象或释放对象, 只适用于 Swift 和 OC 对象以及结构体, 不包括 Core Foundaton 类型对象
2. 每次调用函数(方法)时, 局部对象的变量都会默认初始化为空 13.2.1
1. 循环引用的两个对象都持有彼此的强引用时, 将会产生循环保持(retain cycle), 由于对线仍然有引用, 导致系统不能销毁这个对象
2. 父视图持有子视图的强引用, 子视图持有父视图(弱变量)的弱引用, 弱变量也就不能阻止引用的对象被销毁, 即父视图被销毁后, 子视图无法引用父视图, 无法阻止父视图被销毁
3. 系统会追踪赋值给弱变量的引用, 当引用的对象释放时, 若变量会被自动设置为 nil, 即子视图持有的引用变为 nil, 给已经释放的父视图发消息会发给 nil 对象, 避免程序崩溃
4. 弱变量能够和代理很好的协作, 创建一个代理的弱变量引用, 如果代理对象被销毁, 变量就会被清0
5. 弱变量在 ARC 出现之前, 能够为程序避免很多系统崩溃

ARC 代码与非 ARC 代码混合编译问题

NSWindow, NSTextView, NSFont, NSImage 不支持弱引用???

# 垃圾收集 Garbage Collection

4. drain 消息: 给自动释放池发送 drain 消息, 则自动释放池会被清理, 对象会被释放
