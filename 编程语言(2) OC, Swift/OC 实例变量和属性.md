# 实例变量 Instance Variables

1. 实例变量是类的后端存储数据本身, 相当于类内作用域的静态变量, 多次访问中将保持自己的值, 在该类定义的方法中(类内)按名称直接访问, 类实例(类外)应使用属性访问实例变量
2. 实例变量声明在大括号中, 在接口部分定义的实例变量默认为 @protected , 在实现部分为 @private
3. 类的每个实例都拥有自己的实例变量的一份拷贝

静态实例变量

1. 一个类的所有实例共享一份静态实例变量, OC 没有静态实例变量, 可使用静态局部变量代替

实例变量的访问权限

```
@public 	// 在声明该实例变量的类及子类, 无关代码下均可访问, 在类外需要使用 "->" 操作符访问, 破坏封装性, 不推荐使用
@proteced	// 在声明该实例变量的类及子类中可访问
@private	// 在声明该实例变量的类中访问, 但可以通过继承父类的访问器方法间接地访问父类的私有变量
```

实例变量和属性的对接

1. 实例变量名默认是属性名加下划线前缀, 在实现文件中进行名称对接, `@synthesize var = _var` 表示不同名称的对接, `@synthesize var` 表示实例变量名同属性名
2. 若仅声明属性, 则会自动生成以下划线开头的同名的实例变量, 不再需要 `@synthesize`

# 属性 Properties

1. 属性的本质是实例变量的访问器(accessor)方法, 使用点号运算符访问
2. 属性是实例变量的外部接口, 只能在接口文件中声明, 未命名分类的属性可以在实现文件中的接口部分声明, 私有不可继承

属性修饰符

```
// 访问权限特性
readwrite	// 读写属性, 生成 get 和 set 方法(默认)
readonly	// 只读属性, 只生成 get 方法

// 线程安全特性
atomic		// 原子性访问, 使用互斥(mutex)锁定保护属性的存取方法(默认, 开销较大)
nonatomic	// 非原子性访问, 不使用互斥(mutex)锁定保护属性的存取方法

// 手动引用计数特性
assign		// 直接赋值, 如果是指针将指向同一块内存, 适用于数值类型
retain		// 赋值时先释放旧对象, 再保持新对象, 引用计数加1, 指向同一块内存, 适用于类实例
copy		// 赋值时先释放旧对象, 再拷贝新对象, 引用计数为1, 属性在赋值前后指向不同内存, 适用于字符串

// 自动引用计数特性, 生命周期修饰符 Lifetime Qualifier
strong				// 强引用, 相当于 retain (默认), 影响引用计数
weak				// 弱引用, 相当于 assign, 不影响引用计数
_autoreleaing		//
_unsafe_unretained	//
```

```
self.property = newValue;			// 对于此设值方法调用, 以下是实现

property = newValue;				// assign

if ( property != newValue) {		// retain
	[property release];
	property = [newValue retain];
}

if (property != newValue) {			// copy
	[property release];
	property = [newValue copy];
}
```

# self 和 super 属性

1. self 编译指示符是当前实例对象的引用, 指明调用该方法的实例对象是当前方法的接收者, 指向的对象的首地址, 对象的首地址一般存放的是 isa 变量
2. self 参数是方法的隐藏的参数, id 类型, 是转换为C函数调用时的第一个参数, 指向当前当前调用方法的类, 另一个隐藏参数是 \_cmd, 代表当前类方法的 selector
3. super 是一个“编译器指示符”, 指向和 self 相同的消息接收者, 不同的是 super 告诉编译器调用且只能调用父类的方法, 而不是本类中的方法, 不能赋值给 super , 方法也不能返回 super
4. 使用 self 调用方法时, 会从当前类的方法列表中开始找, 如果没有, 就从父类中再找
5. 使用 super 调用方法时, 则从父类的方法列表中开始找, 然后调用父类的这个方法

# 键值编码

1. 键值编码是一个用于间接访问对象属性的机制，使用该机制不需要调用存取方法和变量实例就可访问对象属性。
2. 键值编码方法在OC非正式协议（类目）NSKeyValueCoding中被声明，默认的实现方法由NSObject提供。
3. 键值编码支持带有对象值的属性，同时也支持纯数值类型和结构。非对象参数和返回类型会被识别并自动封装/解封。

# 键值观察 observe

1. 键值观察是一种使对象获取其他对象特定属性变化的通知机制
2. 控制器层的绑定技术就是严重依赖键值观察获得模型层和控制器层的变化通知的。对于不依赖控制器层类的应用程序，键值观察提供了一种简化的方法来实现检查器并更新用户界面值。
3. 与 NSNotification 不同，键值观察并没有所谓的中心对象来为所有观察者提供变化通知。取而代之的，当有变化发生时，通知被直接发送至处于观察状态的对象。
4. NSObject提供这种基础的键值观察实现方法，你几乎不用重写该方法。
5. 你可以观察任意对象属性，包括简单属性，对一或是对多关系。对多关系的观察者将会被告知发生变化的类型-也就是任意发生变化的对象。键值观察为所有对象提供自动观察兼容性。
6. 你可以通过禁用自动观察通知并实现手动通知来筛选通知。

# 注册观察者

为了正确接收属性的变更通知，观察者必须首先发送一个addObserver:forKeyPath:options:context:消息至被观察对象，用以传送观察对象和需要观察的属性的关键路径，以便与其注册。
选项参数指定了发送变更通知时提供给观察者的信息。使用NSKeyValueObservingOptionOld选项可以将初始对象值以变更字典中的一个项的形式提供给观察者。指定NSKeyValueObservingOptionNew选项可以将新的值以一个项的形式添加至变更字典。你可以使用逐位“|”这两个常量来指定接受上述两种类型的值。
