# 实例变量

1. 实例变量是类的后端存储数据本身, 相当于类内作用域的静态变量, 多次访问中将保持自己的值, 在该类定义的方法中按名称直接访问, 类实例应使用属性访问实例变量
2. 类的每个实例都拥有自己的实例变量的一份拷贝 

# 静态实例变量

1. 一个类的所有实例共享一份静态实例变量

# 属性

1. 属性的本质是实例变量的访问器(accessor)方法, 使用点号运算符
2. 属性是实例变量的外部接口, 只能在接口文件中声明

# 实例变量和属性的对接

1. 实例变量名默认是属性名加下划线前缀, 在实现文件中进行名称对接, `@synthesize var = _var` 表示不同名称的对接, `@synthesize var` 表示实例变量名同属性名
2. 若仅声明属性, 则会自动生成以下划线开头的同名的实例变量, 不再需要 `@synthesize`

# 实例变量的访问权限

1. 公有实例变量(@public): 在声明该实例变量的类, 子类, 无关代码下均可访问, 在类外需要使用 "->" 操作符访问, 破坏封装性, 不推荐使用
2. 受保护实例变量(@proteced): 在声明该实例变量的类, 子类中可访问(默认)
3. 私有实例变量(@private): 在声明该实例变量的类中访问, 但可以通过继承父类的访问器方法访问父类的私有变量

# 属性的特性

访问权限特性

1. readonly: 只读属性, 只生成 get 方法
2. readwrite: 读写属性, 生成 get 和 set 方法(默认)

线程安全特性

1. nonatomic: 非原子性访问, 不使用互斥(mutex)锁定保护属性的存取方法
2. atomic: 原子性访问: 使用互斥(mutex)锁定保护属性的存取方法(默认), 开销较大

引用计数特性

1. assign: 直接赋值, 如果是指针将指向同一块内存, 适用于数值类型
2. retain: 先释放旧对象, 再保持新对象, 引用计数加1, 指向同一块内存, 适用于类实例
3. copy: 先释放旧对象, 再创建新对象, 引用计数为1, 属性在赋值前后指向不同内存, 适用于字符串

自动引用计数特性

1. strong: 强引用, 相当于 retain (默认)
2. weak: 弱引用, 相当于 assign

```
self.property = newValue;			// 设置方法调用, 以下是实现

property = newValue;				// assign

if ( property != newValue) {		// retain
	[property release];
	property = [newValue retain];
}

if (property != newValue) {			// copy
	[property release];
	property = [newValue copy];
}
```
