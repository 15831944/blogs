# 消息 Message

1. 消息(Message): 消息是对象之间通信的唯一手段, 接收方无须返回应答
2. 发送者(Sender): 执行该消息代码的对象, NSApplication, UIApplication 对象
3. 接收者(Receiver):
2. 输出口(Outlet): 对象之间通过"一个对象的某个属性是另一个对象的变量"建立的, 没有引用关系的两个对象之间无法发送消息, 连接对象的变量称为输出口
3. 消息表达式(Message Expression): 方括号
4. 消息关键字(Message Keyword): 冒号前的各个参数的名字, 提高消息名的可读性
5. 消息选择器(Message Selector): 即方法名, 消息名, 包括冒号部分, 不包括参数和返回值类型信息
5. 消息签名(Signature): 消息选择器和参数及返回值类型信息结合起来构成签名, 用于运行时标记一个方法, 接口文件中的方法声明属于签名, 如果消息接收者和参数的类型是运行时(方法返回值类型为静态类型不存在此问题)确定的, 那么消息签名不唯一的话编译就会报错(尤其是继承关系的类), 即选择器相同的消息, 参数和返回值类型也应该是相同的, 由于参数的类型是在运行时确定的, 因此不支持重载
1. 内置变量: \_cmd 始终包含当前方法的选择器, 选择器是 OC 引用方法的一种方式
1. 选择子(selector): SEL 类型的值, 整数? 使用 `@selector` 指令产生, 用于指定方法, 为指定方法生成一个 SEL 类型的值
2. 尾部调用优化:

# 方法 Methods

`- (int)showWithA:(int)a andB:(int)b;`

1. 方法: 使用类实例(经过 alloc 初始化的对象引用)进行调用, 方法可以访问该类的实例变量
2. 类方法: 静态方法, 使用类名进行调用, 只能访问静态成员变量
3. 方法的本质: 方法是向对象发消息, 本质是调用与接收者对象相关的函数, 函数参数除了自身的参数外还包括接收者(self 指针, isa 指针?)
4. 方法的声明: "-"表示对象方法, "+"表示静态方法, 参数写在":"后, 返回值类型和参数类型写在"()"中, 函数名包括冒号及变量名后面的空格
5. 方法的类型: 方法的默认返回类型为 id 类型, 推荐显式声明返回类型, 函数的默认返回类型为整型
6. 方法的调用: 用方括号调用方法(也可以使用点运算符调用方法, 但不推荐, 一般用点运算符访问成员变量)
7. alloc 方法保证对象的所有实例变量都变成初始状态(0值), 但对象未正确初始化, 返回成员数据的首地址
8. id 类型的方法只是返回指向内存中某个对象的指针, 对象总是携带 isa 成员, 因此总能确定对象的类, 方法的默认返回类型为 id 类型(如果省略 void, 就像 C 默认 int)
9. 强制使用父类调用子类的方法? (8.3.1节)

1. 方法签名: NSMethodSignature 类的实例

# 类方法 Class Methods

1. 类方法又称为工厂方法, 用于快速创建对象的类方法，我们称之为类工厂方法, 主要用于给对象分配并初始化内存, 例如 alloc 方法
2. initialize 类方法: NSObject 根类的 initialize 类方法为各类对象进行初始化, 子类隐式自动调用父类的 initialize 方法, 每个类只调用一次
3. self 类方法: 如果没有任何需要被初始化的变量, 可发送 self 消息返回接收者自身, 没有多余操作

# 方法族 Method Family

1. 同对象的生成和复制相关的方法的集合, 以 alloc, copy, mutableCopy, new, init 开头, 返回的对象必须是可以被 retain 的, 称为可被保持的对象(retainable object), 包括 OC 对象和 block 对象

# 构造器方法 Initializer

1. 构造器方法: init 方法, 在程序开始时, 向所有的类发送 initialize 调用方法, 只发送一次, 用于初始化成员变量, 返回值类型可以是 id (任意对象类型)或 instancetype (当前类的类型)
2. 构造器方法的重写(Override): 需要在接口文件中重新声明, init 方法, 名称不变, 可对成员变量进行初始化, 返回 self
3. 构造器方法的覆盖: 以 init 开头的方法名, 自定义操作, 以 new, alloc, copy, init 开头的方法与编译器的一些假定有关
4. 指定初始化方法(Designated Initializer): 一般为最复杂的, 参数最多的初始化方法, 能确保所有实例变量都能被初始化, 其他初始化方法会调用指定初始化方法完成初始化, 子类的(或重写的)指定初始化方法或必须调用父类的指定初始化方法, 否则易造成递归循环, 应使用注释标明指定初始化方法
5. 非指定初始化方法(Secondary Initializer):
1. 使用对象类型开头的便利构造器方法实例化的对象自动添加 autorelease 消息, 自动释放内存, 使用 init 开头的指定构造器方法实例化对象需要手动释放内存
为什么从上到下一级一级构造?
初始化方法的返回值应为 id 类型, 避免使用静态类型写死, 这样子类调用父类的初始化方法时就可以返回子类而不是父类

# 析构函数 Deinitializer

5. 析构函数: 为了能够释放由当前对象创建或保持的实例变量或其他对象, 需要覆写 dealloc 方法

# 访问器方法 Accessor

1. 取值方法: [instance property] 等价于 instance.property
2. 设值方法: [instance setProperty: value] 等价于 instance.property = value
3. 由属性生成的默认的访问器方法是传址调用

# 块对象 Blocks

1. 块的定义: 块是C语言的功能实现, 是对C的扩展, 像函数一样可以传参且具有返回值, 类似于 swift 中的闭包(Closure) (OC程序设计13.3节)
2. 块的用法: 块可以定义在函数内部(或外部), 能够访问在函数范围内的任何变量, 可以定义为块对象, 能够作为参数传递给函数
3. 块的作用: 使用块对象作为参数的函数, 可以传入不同的块, 相比于传入函数指针, 可以根据上下文信息, 使函数功能独立灵活, 系统能够让将块分配给其他处理器或应用的其他线程执行(使用 GCD 多线程)
4. 块句法(block literal): 包含参数列表和主体, 类似于函数定义, 块对象的块句法用于定义块对象, 并不被用于在内存中分配块对象, 只是表达用语, 需要赋值给变量, 传入的函数参数可以直接写为块句法
5. 块对象(block object): 使用 ^ 定义, 定义和用法均类似于函数指针, 块对象将可执行代码及代码可访问的变量封装起来, 合成一个单元使用, 用于代入到变量, 变量可以像函数一样被调用执行, 可以作为函数参数传入
6. 块对象的类型: 可以使用 typedef 声明类型, 编译器自动推测返回值类型, 不需指明
7. 块指针: 类似于函数名

块对象中的变量行为

1. 捕获(capture): 闭包是把变量等执行环境封装起来的意思, 把闭包引用, 读取外部变量称为捕获
2. 块对象只在块句法中保存块句法所在代码块内的自动变量(栈内变量)的值, 块对象的执行(使用自动变量时, 不会知道自动变量是否已发生变化, 块实现中), 不能改变(只能读取)自动变量的值, 因为实际使用的是捕获到的自动变量的值而不是其本身, 自动变量不能是数组, 静态变量的值会直接被改变

块对象实体

编译块句法时, 会生成存放必要信息的内存地址(实体为结构体)和函数, 变量中代入的或向函数传入的实参, 实际上是指向这片内存区域的指针

1. 若块对象定义在函数外部, 块句法被编译后, 块对象的内存区域就同外部变量一样被配置在了静态数据区中
2. 若块对象定义在函数内部, 块句法被编译后, 在执行包含该块句法的函数时, 和函数内的自动变量相同, 块对象的内存区域会在栈上得到分配且只会分配一个实体, 为的是可以在反复执行时, 更新捕获的值

块对象的复制和释放

```
Block_copy(block)		// 若参数为栈上的块对象, 则复制块对象到新的堆区域并将其返回, 若参数为堆上的块对象, 则直接将其返回并 retain
Block_release(block)	// 减少参数的块对象的引用计数, 减到0时释放块对象的内存区域
```

块修改器

1. 使用块修改器(\_\_block)修饰块外自动变量, 则该变量作用域内的多个块对象可以对其进行修改, 即共享其值
2. \_\_block 变量在块对象执行时动态生成, 所有访问 \_\_block 变量的块对象都不存在, 则 \_\_block 才会随之消失

# 高阶函数

1. 使用函数指针作为参数的函数有 qsort, 方法有 sortUsingFoundation:context, 可对任意数组进行排序
2. 高阶函数还可以用于分派表 (OC程序设计13.5.4节)

# C 函数的使用

1. C 函数中可以调用 OC 方法, 参数和返回值可以是 id 类型
2. C 函数不可以使用类实现文件中的实例变量和 self 变量, 但可以作为参数传递给 C 函数

# 写回传

通过函数的参数传入一个指针, 将返回值写入指针指向的空间, 变相的实现函数返回多个返回值, 在 C 中称为按引用传递(pass-by-reference), 在 OC 中叫做写回传(pass-by-writeback), 实现方式不同, 实现通过函数参数返回结果对象
只可以把 nil 或 临时变量的指针 用于写回传, 不可以把 静态变量的指针, 数组首地址的指针, 内部变量的指针 用于写回传

```
