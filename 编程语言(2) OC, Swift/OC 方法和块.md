# 消息 Message

1. 消息(Message): 消息是对象之间通信的唯一手段, 接收方无须返回应答
2. 发送者(Sender):
3. 接收者(Receiver):
2. 输出口(Outlet): 对象之间通过"一个对象的某个属性是另一个对象的变量"建立的, 没有引用关系的两个对象之间无法发送消息, 连接对象的变量称为输出口
3. 消息表达式(Message Expression): 方括号
4. 消息关键字(Message Keyword): 冒号前的各个参数的名字, 提高消息名的可读性
5. 消息选择器(Message Selector): 即方法名, 消息名, 包括冒号部分, 不包括参数和返回值类型信息
5. 消息签名(Signature): 消息选择器和参数及返回值类型信息结合起来构成签名, 用于运行时标记一个方法, 接口文件中的方法声明属于签名, 如果消息接收者和参数的类型是运行时(方法返回值类型为静态类型不存在此问题)确定的, 那么消息签名不唯一的话编译就会报错(尤其是继承关系的类), 即选择器相同的消息, 参数和返回值类型也应该是相同的, 由于参数的类型是在运行时确定的, 因此不支持重载
1. 内置变量: \_cmd 始终包含当前方法的选择器, 选择器是 OC 引用方法的一种方式
1. 选择子(selector): SEL 类型的值, 整数? 使用 `@selector` 指令产生, 用于指定方法, 为指定方法生成一个 SEL 类型的值
2. 尾部调用优化:

# 方法 Methods

`- (int)showWithA:(int)a andB:(int)b;`

1. 方法: 使用类实例(经过 alloc 初始化的对象引用)进行调用, 方法可以访问该类的实例变量
2. 类方法: 静态方法, 使用类名进行调用, 只能访问静态成员变量
3. 方法的本质: 方法是向对象发消息, 本质是调用与接收者对象相关的函数, 函数参数除了自身的参数外还包括接收者(self 指针, isa 指针?)
4. 方法的声明: "-"表示对象方法, "+"表示静态方法, 参数写在":"后, 返回值类型和参数类型写在"()"中, 函数名包括冒号及变量名后面的空格
5. 方法的类型: 方法的默认返回类型为 id 类型, 推荐显式声明返回类型, 函数的默认返回类型为整型
6. 方法的调用: 用方括号调用方法(也可以使用点运算符调用方法, 但不推荐, 一般用点运算符访问成员变量)
7. alloc 方法保证对象的所有实例变量都变成初始状态(0值), 但对象未正确初始化, 返回成员数据的首地址
8. id 类型的方法只是返回指向内存中某个对象的指针, 对象总是携带 isa 成员, 因此总能确定对象的类, 方法的默认返回类型为 id 类型(如果省略 void, 就像 C 默认 int)
9. 强制使用父类调用子类的方法? (8.3.1节)

1. 方法签名: NSMethodSignature 类的实例

# 类方法 Class Methods

1. 类方法又称为工厂方法, 用于快速创建对象的类方法，我们称之为类工厂方法, 主要用于给对象分配并初始化内存, 例如 alloc 方法
2. initialize 类方法: NSObject 根类的 initialize 类方法为各类对象进行初始化, 子类隐式自动调用父类的 initialize 方法, 每个类只调用一次
3. self 类方法: 如果没有任何需要被初始化的变量, 可发送 self 消息返回接收者自身, 没有多余操作

# 方法族 Method Family

1. 以 init, set 开头

# 构造器方法 Initializer

1. 构造器方法: init 方法, 在程序开始时, 向所有的类发送 initialize 调用方法, 只发送一次, 用于初始化成员变量, 返回值类型可以是 id (任意对象类型)或 instancetype (当前类的类型)
2. 构造器方法的重写(Override): 需要在接口文件中重新声明, init 方法, 名称不变, 可对成员变量进行初始化, 返回 self
3. 构造器方法的覆盖: 以 init 开头的方法名, 自定义操作, 以 new, alloc, copy, init 开头的方法与编译器的一些假定有关
4. 指定初始化方法(Designated Initializer): 一般为最复杂的, 参数最多的初始化方法, 能确保所有实例变量都能被初始化, 其他初始化方法会调用指定初始化方法完成初始化, 子类的(或重写的)指定初始化方法或必须调用父类的指定初始化方法, 否则易造成递归循环, 应使用注释标明指定初始化方法
5. 非指定初始化方法(Secondary Initializer):
1. 使用对象类型开头的便利构造器方法实例化的对象自动添加 autorelease 消息, 自动释放内存, 使用 init 开头的指定构造器方法实例化对象需要手动释放内存
为什么从上到下一级一级构造?
初始化方法的返回值应为 id 类型, 避免使用静态类型写死, 这样子类调用父类的初始化方法时就可以返回子类而不是父类

# 析构函数 Deinitializer

5. 析构函数: 为了能够释放由当前对象创建或保持的实例变量或其他对象, 需要覆写 dealloc 方法

# 访问器方法 Accessor

1. 取值方法: [instance property] 等价于 instance.property
2. 设值方法: [instance setProperty: value] 等价于 instance.property = value
3. 由属性生成的默认的访问器方法是传址调用

# 块 Blocks

1. 块是 Apple 对 C 语言的扩展, 像函数一样可以传参且具有返回值, 定义在函数或者方法内部, 能够访问在函数或者方法范围内的任何变量, 能够作为参数传递给函数或方法, 能够让系统分配给其他处理器或应用的其他线程执行, 类似于 swift 中的闭包 13.3
3. 块修改器: 块外变量可以使用块修改器(\_\_block)修改, 否则为只读
5. 块指针: 类似于函数名

# 高阶函数

1. 使用函数指针作为参数的函数有 qsort, 方法有 sortUsingFoundation:context, 可对任意数组进行排序
2. 高阶函数还可以用于分派表 13.5.4

# C 函数的使用

1. C 函数中可以调用 OC 方法, 参数和返回值可以是 id 类型
2. C 函数不可以使用类实现文件中的实例变量和 self 变量, 但可以作为参数传递给 C 函数
