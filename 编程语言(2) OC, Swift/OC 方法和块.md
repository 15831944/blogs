# 消息 Message

1. 消息(Message): 消息是对象之间通信的唯一手段, 消息接收者无须返回应答
2. 发送者(Sender): 执行该消息代码的对象, 向委托对象发送者消息的对象(例如 NSApplication, UIApplication 对象)
3. 接收者(Receiver): 发送者对象的属性
4. 输出口(Outlet): 对象之间通过"一个对象的某个属性是另一个对象"建立的, 没有引用关系的两个对象之间无法发送消息, 连接对象的变量称为输出口
5. 消息表达式(Message Expression): 用方括号调用方法, 也可以使用点运算符调用方法, 但不推荐, 点运算符一般用于调用访问方法访问成员变量
6. 消息关键字(Message Keyword): 冒号前的各个参数的名字, 提高消息名称的可读性
7. 消息选择器(Message Selector): 选择器是 OC 调用方法的一种方式, 消息选择器即方法名, 包括冒号部分, 不包括参数和返回值的类型信息, 本质是 char 指针
8. 消息签名(Signature): 消息选择器和参数及返回值类型信息结合起来构成签名, 用于运行时标记一个方法, 接口文件中的方法声明属于签名
9. 选择子(Selector): SEL 类型的值, 使用 `@selector` 指令产生, 将方法名生成一个 SEL 类型的值, 只要方法名相同, 生成的值就相同, 作为 hash 表的键值, 用于快速查找方法

# 方法 Method

1. 方法: 使用实例对象进行调用, 可以访问该类的实例变量, 方法定义了自身可以接收的消息, 方法调用即向对象发消息, 本质是转换为消息接收者self, 选择子_cmd, 以及方法自身参数为参数的函数
2. 类方法(Class Methods): 又称静态方法, 工厂方法, 使用类对象进行调用, 只能访问该类的静态成员变量
3. 类工厂方法: 用于快速创建对象的类方法, 称为类工厂方法, 主要用于给对象分配并初始化内存
4. 方法族(Method Family): 同对象的生成和复制相关的方法的集合, 以 alloc, copy, mutableCopy, new, init 开头, 返回的对象必须是可被保持的对象(retainable object), 包括 OC 对象和 block 对象
5. 方法声明: "-"表示对象方法, "+"表示静态方法, 参数写在":"后, 返回值类型和参数类型写在"()"中, 方法名包括冒号及变量名后面的空格
6. 方法类型: 方法的默认返回类型为 id 类型, 函数的默认返回类型为整型, 推荐显式声明返回类型, id 类型的方法只是返回指向内存中某个对象的指针, 对象总是携带 isa 成员, 因此总能确定对象的类
7. 访问器方法(Accessor): 包括取值方法和设值方法, 使用点运算符调用, 属性生成的访问器方法默认为传址调用
8. 方法的重写(Override): 子类需要在其接口文件中重新声明要重写的方法
9. 方法的重载(Overload): OC 不支持方法重载, 如果消息的接收者和参数类型是运行时确定的动态类型, 则互为重载的各函数的选择器将是相同的, 即消息签名不唯一, 会导致运行时错误, 若方法返回值类型为静态类型则不存在此问题
0. 方法的覆盖:
1. 构造器方法(Initializer): init 开头的方法族, 可对成员变量进行初始化, 返回值应避免用静态类型写死, 这样子类调用父类的初始化方法时就可以返回子类而不是父类, 赋给 self, 在程序开始时, 向所有的类发送 initialize 消息
2. 指定初始化方法(Designated Initializer): 参数最多最复杂的初始化方法, 能确保所有实例变量都被初始化, 子类的(重写的)指定初始化方法或必须调用父类的指定初始化方法, 否则易造成递归死循环, 应使用注释标明指定初始化方法
3. 非指定初始化方法(Secondary Initializer): 可调用指定初始化方法完成初始化
4. 便利初始化方法(Convenient Initializer): 以对象类型开头的便利构造器方法实例化的对象会自动调用 autorelease 消息, 自动释放内存, 使用 init 开头的指定构造器方法实例化对象需要手动释放内存
5. 析构函数(Deinitializer): 为了能够释放由当前对象创建或保持的实例变量或其他对象, 需要覆写 dealloc 方法

```
initialize	// 继承自 NSObject 根类, 为类对象的成员变量进行初始化, 子类的构造器方法会隐式地自动调用父类的 initialize 方法, 每个类只调用一次, 返回值类型可以是 id (任意对象类型)或 instancetype (当前类的类型)
self		// 如果没有任何需要被初始化的变量, 可发送 self 消息返回接收者自身, 没有多余操作
```

# C 函数的使用

1. C 函数的参数和返回值可以是 id 类型, 函数中可以调用 OC 方法, 但不可以使用类的实例变量或 self 变量, 只能作为参数传入

# 写回传

1. 写回传(pass-by-writeback): 通过函数的参数传入一个指针, 并将返回值写入该指针指向的空间, 则变相地实现函数了返回多个返回值, 叫做写回传(在 C 中称为按引用传递, pass-by-reference)
2. 写回传用于通过函数参数返回结果对象, 只可以把 nil 或 临时对象的指针 用于写回传, 不可以把 静态变量的指针, 数组首地址的指针, 内部变量的指针 用于写回传

# 块对象 Blocks

1. 块的定义: 块是C语言的功能实现, 是对C的扩展, 像函数一样可以传参且具有返回值, 类似于 swift 中的闭包(Closure) (OC程序设计13.3节)
2. 块的用法: 块可以定义在函数内部(或外部), 能够访问在函数范围内的任何变量, 可以定义为块对象, 能够作为参数传递给函数
3. 块的作用: 使用块对象作为参数的函数, 可以传入不同的块, 相比于传入函数指针, 可以根据上下文信息, 使函数功能独立灵活, 系统能够将块分配给其他处理器或应用的其他线程执行(使用 GCD 多线程)
4. 块句法(block literal): 包含参数列表和主体, 类似于函数定义, 块对象的块句法用于定义块对象, 并不被用于在内存中分配块对象, 只是表达用语, 需要赋值给变量, 传入的函数参数可以直接写为块句法
5. 块对象(block object): 使用 ^ 定义, 定义和用法均类似于函数指针, 块对象将可执行代码及代码可访问的变量封装起来, 合成一个单元使用, 用于代入到变量, 变量可以像函数一样被调用执行, 可以作为函数参数传入
6. 块对象的类型: 可以使用 typedef 声明类型, 编译器自动推测返回值类型, 不需指明
7. 块指针: 类似于函数名

块对象中的变量行为

1. 捕获(capture): 闭包是把变量等执行环境封装起来的意思, 把闭包引用, 读取外部变量称为捕获
2. 块对象只在块句法中保存块句法所在代码块内的自动变量(栈内变量)的值, 块对象的执行(使用自动变量时, 不会知道自动变量是否已发生变化, 块实现中), 不能改变(只能读取)自动变量的值, 因为实际使用的是捕获到的自动变量的值而不是其本身, 自动变量不能是数组, 静态变量的值会直接被改变

块对象实体

编译块句法时, 会生成存放必要信息的内存地址(实体为结构体)和函数, 变量中代入的或向函数传入的实参, 实际上是指向这片内存区域的指针

1. 若块对象定义在函数外部, 块句法被编译后, 块对象的内存区域就同外部变量一样被配置在了静态数据区中
2. 若块对象定义在函数内部, 块句法被编译后, 在执行包含该块句法的函数时, 和函数内的自动变量相同, 块对象的内存区域会在栈上得到分配且只会分配一个实体, 为的是可以在反复执行时, 更新捕获的值

块对象的复制和释放

```
Block_copy(block)		// 若参数为栈上的块对象, 则复制块对象到新的堆区域并将其返回, 若参数为堆上的块对象, 则直接将其返回并 retain
Block_release(block)	// 减少参数的块对象的引用计数, 减到0时释放块对象的内存区域
```

块修改器

1. 使用块修改器(\_\_block)修饰块外自动变量, 则该变量作用域内的多个块对象可以对其进行修改, 即共享其值
2. \_\_block 变量在块对象执行时动态生成, 所有访问 \_\_block 变量的块对象都不存在, 则 \_\_block 才会随之消失
