# 概念

1. OC 由 GNU 接管, 可以用于 Linux 嵌入式开发和服务器端开发
2. OC 文件扩展名为".m", 与 C++ 混编的文件扩展名为 ".mm"
3. Foundation 框架和 UIKit 框架是 OC 语言编写的
4. OC 具有封装, 继承, 多态, 重用; 不具有重载, 模版, 多继承, 垃圾回收机制(Cocoa Touch 不支持垃圾回收)
5. OC 的优势是它的动态能力
6. 动态类: 运行时确定类的对象
7. 动态绑定: 运行时确定要调用的方法
8. 动态加载: 运行时为程序加载新的模块

```
// 头文件, 类的声明
@interface SimpleClass: NSObject		// 类名, 继承的类名
{
	@protected							// 成员变量访问限定符
	NSString	*_name;					// 成员变量(更推荐写在实现文件中)
}
@property (readonly) NSString	*name	// 属性
-(void) method;							// 方法
+(id) staticMethod;						// 静态方法
@end

// 源文件, 类的实现
#import "SimpleClass.h"					// 包含类声明的头文件
@implementation ClassName				// 类名
{
	NSString *_name;					// 成员变量
}
-(void) method{							// 方法的实现
	_name = @"string";					// 访问成员变量
	NSLog(@"Hello World");
}
@end
```

# 数据类型

1. 基本数据类型: int, float, double, char
2. 类型修饰符: long, long long, short, signed, unsigned
3. 整型类型变量默认初始值为0(不是任意值)
4. 枚举类型可以在冒号后面指定数据类型
5. 复合字面量: (type) {initialize list}, 可以用于初始化结构或数组
6. 布尔类型变量本质是预处理机制, 使用预定义的值 YES 和 NO
7. id 类型是通用指针类型, 可以强制类型转换为指定类型的对象, 是多态和动态绑定的基础
8. id 类型的方法只是返回指向内存中某个对象的指针, 对象总是携带 isa 成员, 因此总能确定对象的类
9. nil 是 id 类型, 本质是指针类型, 声明时没有星号
10. instancetype 类型, 决定了基于上下文的返回类型, 被继承时, 可以正确返回子类
11. 程序为了性能优化, 可能要求使用底层数据类型, 例如存储大量数据的数组, 可能会使用 C 语言的内置数据结构, 而不是 Foundation 框架提供的数组对象

# 常量

1. 0, 0x 分别表示八进制和十六进制, f, l, u, ll 前缀用于表示字面值的数据类型

# 运算符

1. 条件运算符从右向左结合, OC 支持非 ANSI 扩展的语句:` condition ? : expression`

# 语句

1. switch 语句支持整型和字符型
2. 使用编译器选项 `-W Conversion` 和 `-Wswitch`, 当赋值和枚举类型表达式或枚举常量应用在 switch 语句时, 提供类型检查

# 变量

1. 普通实例变量: 每个对象都有该变量的拷贝, 在多次方法调用时保持自己的值
2. 静态实例变量: 所有的方法都可以访问
3. 普通局部变量: 初始值为 nil, 方法返回即失效, 方法的参数属于局部变量
4. 静态局部变量: 初始值为0, 只能通过声明该变量的方法访问, 每个对象访问的是同一个变量
5. 全局变量: 习惯用 g 开头, 声明不会引起变量存储空间分配, 定义会, 因此 extern 应只用于声明, 不建议用 extern 声明的同时进行定义和初始化
6. 如果只有少数方法要访问某全局变量, 可以在使用前单独进行 extern 声明, 外部全局变量会破坏封装性

# 类, 对象

1. 面向对象的理念就是将同一个方法应用于不同的对象, 对象的本质是结构, 对象的实例变量是结构的成员变量, 继承的实例变量和对象自身的变量组成了新的结构
2. 对象变量是指向结构的指针, 因此才可以用"->"运算符访问 `@public` 修饰的成员变量(不推荐)
3. 使用 alloc, init 方法或 new 方法(不推荐)实例化对象, 对象都通过对象指针进行引用, 即传址调用
4. 使用 `@class` 声明当前声明的类要用到的类, 可使用该类的属性, 提高效率, 但要使用该类的方法, 则需包含整个头文件

# 属性, 成员变量

1. 成员变量: 使用大括号声明在接口文件`@interface`(公有, 可以被继承)或实现文件`@implementation`(私有)中, 在类内按名称直接访问, 推荐后者方式
2. 属性: 是成员变量的外部接口, 只能在接口文件中声明, 本质是调用 set 和 get 方法访问成员变量, 叫做访问器(accessor)方法(since OC 2.0), 在类外使用 "." 运算符调用方法进行访问
3. 成员变量名是属性名加下划线前缀, 二者内存操作不同, 在实现文件中使用 `@synthesize var = _var` 的形式将成员变量名和属性名进行对接
4. 若只在头文件中声明属性, 则会自动生成以下划线开头的同名的成员变量, 不再需要 `@synthesize`
5. 成员变量被访问限定符修饰, 默认为 protected
6. 方法没有访问限定符, 方法的属性类似于 C 语言, 在头文件中声明则具有外部属性, 相当于公有, 可以被继承, 在实现文件中声明则为该类私有, 不能被继承

| qualifier  | 类外                          | 类内               | 继承性 |
| ---------- | ---------------------------- | ------------------ | ----- |
| @public    | 只能使用 "->" 操作符访问(不推荐) | 使用成员变量名直接访问 | 允许 |
| @proteced  | 禁止                          | 使用成员变量名直接访问 | 允许 |
| @private   | 禁止                          | 使用成员变量名直接访问 | 禁止 |
| @package   | 在框架内, 相当于私有            | 在框架外, 相当于受保护 |     |

# 方法

`- (int)showWithA:(int)a andB:(int)b;`

1. 方法是函数, 消息表达式的本质是函数调用, 调用方法时, 是在调用与接收者相关的函数, 传递给函数的参数是接收者(self)和方法的参数
1. 对象方法: 使用对象实例(经过 alloc)进行调用, 可以访问该类的成员变量
2. 类方法(静态方法): 使用类名进行调用, 只能访问静态成员变量
3. 方法声明: "-"表示对象方法, "+"表示静态方法, 参数写在":"后, 返回值类型和参数类型写在"()"中, 函数名包括冒号及变量名后面的空格
4. init 方法的返回值类型可以是 id (任意对象类型)或 instancetype (当前类的类型)
5. 重写初始化方法: 方法名不变, 对成员变量进行初始化, 返回 self
6. 自定义初始化方法: 以 init 开头的方法名
7. 取值方法: [instance property] 等价于 instance.property
8. 设值方法: [instance setProperty: value] 等价于 instance.property = value
9. alloc 方法保证对象的所有实例变量都变成初始状态(0值), 但对象未正确初始化, 返回成员数据的首地址
10. init 方法用于初始化类的成员变量
11. new, alloc, copy, init 开头的方法与编译器的一些假定有关
12. 用点运算符访问成员变量, 用方括号调用方法(也可以使用点运算符调用方法, 但不推荐)
13. 强制使用父类调用子类的方法? (8.3.1节)
14. 指定的(designated)初始化方法: 一般为最复杂的, 参数最多的初始化方法, 子类可以重写此方法
15. initialize 方法: 在程序开始时, 向所有的类发送 initialize 调用方法, 只发送一次, 用于初始化与类相关的静态变量
16. 函数的默认返回类型为整型, 方法的默认返回类型为 id 类型, 推荐显式声明返回类型
17. 静态方法没有传入 isa 指针?

# 块 blocks

1. 块是 Apple 对 C 语言的扩展, 看起来像函数, 可以传参, 具有返回值, 类似于 swift 中的闭包 13.3
2. 块定义在函数或者方法内部, 并能够访问在函数或者方法范围内, 块之外的任何变量
3. 块修改器: 块外变量可以使用块修改器(\_\_block)修改, 否则为只读
4. 块能够作为参数传递给函数或方法, 能够让系统分配给其他处理器或应用的其他线程执行
5. 块指针: 类似于函数名

# 消息发送和转发

1. 消息的发送者:
2. 消息的接收者: 请求一个类或实例来执行某个操作时, 就是在向它发送一条消息, 方法执行的上下文环境就是接收到消息的对象
3. 方法的查找: 先查找本类有没有该名称的方法, 没找到则继续查找父类
4. 消息的转发: forwardInvocation: 方法

# 封装

1. 封装的作用是使具体实现不可见，只向用户提供方法调用的接口, 有利于更好的对事物进行抽象
2. 数据封装的原则就是不能在类外直接设置或获取实例变量的值, 而是需要 set 和 get 方法, 否则会难以跟踪, 调试和修改

# 继承

1. Objective C 不支持多继承, 用协议实现类似功能
2. 私有成员变量不可以被继承, 若父类方法中使用了父类的私有变量, 则可以通过继承父类的方法, 间接的使用父类的私有成员变量
3. 在实现部分声明或合成的实例变量是私有的, 不能被继承
4. 类的每个实例都拥有自己的实例变量, 即使这些实例变量是继承来的, 且拥有父类实例变量的值
5. 子类和父类的成员变量不可重名
6. 抽象类(abstract superclasses): 不能实例化, 例如 NSNumber 类, 每个具体子类属于 NSNumber 类, 总称为簇(cluster), 子类是私有的, 只能通过抽象的超类间接访问
7. 初始化子类时应先初始化父类(类似于 C++ 中构造函数需要从继承链父类到子类一级一级的初始化)

# 多态

1. 一个父类可以有多个子类，每个子类在继承了父类的方法后，对该父类方法分别进行重写，那么每个子类的方法是不一样的，一个父类方法被改写成多种形态，叫做多态, 方法名相同, 因此是同一个消息, 接收者不同, 即可以向不同类的对象发送相同的消息
2. 如果一种语言不支持多态，那么它只能称为基于对象，而不能称为面向对象
3. 方法重写: 方法的返回值类型, 名称, 参数类型和数量均相同, 使用 super 调用父类方法, 使用 self 调用当前类方法(相当于递归调用), 在分类中覆写方法会导致原方法无法访问
4. 方法重载: 方法名相同的函数互为重载, OC 不支持方法重载, 因此方法的返回值类型和参数类型需要是静态类型, 才能找到正确的方法
5. 使用父类对象指针指向子类对象, 会调用子类的重写的方法
6. id 类型: 不可以使用点运算符
6. 静态类型: 对存储在变量中的对象的类型进行显式声明, 在编译时进行检查
6. 动态类型: 能是程序直到执行时才能确定对象所属的类
7. 动态绑定: 能使程序知道执行时才确定实际要调用的对象方法
8. 使用 class 方法根据类名或另一个对象生成一个类对象
9. selector 是一个 SEL 类型的值, 使用 `@selector` 指令产生, 用于指定方法, 为指定方法生成一个 SEL 类型的值

# 异常

1. NSException 对象包含异常信息, 作为参数传递给`@ catch` 块
2. `@try`, `@catch`, `@finally`
3. `@throw`

# 分类 category

1. 模块(module): 引用包含在一个源文件中的任何数目的方法或者函数定义, 为系统头文件提供更快的处理速度(重新编译它们)和避免了潜在的命名冲突, 如 `#import UIKit`
2. 将类的定义模块化到相关的方法的组或分类中, 是更简便的扩展类的方式, 无须访问类的源代码, 无须创建子类
3. 分类可以访问主类的实例变量和方法, 不能在分类中列出父类或实例变量, 因为主类已经向编译器告知了实例变量
4. 分类的文件名称习惯为: 主类名接分类名
5. 分类的接口可以定义在单独的接口文件中(应包含主类的头文件)或写在主类接口文件下面(前提是可以访问主类的源代码)
6. 分类的实现可以定义在单独的实现文件中(主类不能访问分类方法)或写在主类实现文件下面(该类的所有用户都可以访问分类中的方法)
7. 未命名的分类: 用于类的扩展, 可以定义额外的实例变量和属性(有命名的分类不允许)
8. OC 名称空间是程序代码与所有的库, 框架和插件共享的
9. 通过分类向主类添加的方法可以被子类继承

```
#import ClassName.h
@interface ClassName (Category)			// 分类的定义
@interface ClassName ()					// 未命名分类的定义
@implementation ClassName (Category)	// 分类的实现
```

# 协议 protocol

1. 协议是两个类之间的接口定义, 是多个类共享的一个方法列表, 是无类的(classless), 即不引用任何类
2. 定义了协议的类可以看作是将协议定义的方法代理给了实现他们的类, 需要在类的实现文件中实现协议定义的方法
3. 遵守(confirm to)或采用(adopt)协议表示实现该协议的所有方法, 实现的协议的方法可以被继承, 分类也可以采用协议
4. 协议可进行扩展, 定义新协议采用已有协议

```
@protocol NSCopying										// 协议的定义
@optional												// 定义协议中可选的实现, 用于取代非正式协议的使用
@required												// 定义协议中需要的实现
@interface ClassName: SuperClass <NSCopying, NSCoding>	// 协议的采用(声明的类采用指定协议)
id <NSCopying, NSCoding> currentObject;					// 定义遵守指定协议的变量
@protocol Drawing3d <Drawing>							// 协议的扩展
@interface ClassName (Category) <NSCopying>				// 定义采用指定协议的分类
```

```
BOOL c = [currentObject conformToProtocol: @protocol (protocolName)];	// 指定类是否满足指定协议
BOOL c = [currentObject respondsToSelector: @selector (method)];		// 指定类是否实现指定方法
```

# 代理(委托) delegate

1. 采用某个协议的类实现了协议定义的方法, 可称作代理类
2. UITableView 类遵循 UITableViewDataSource 协议和 UITableViewDelegate 协议, 让用户决定表格中每个区块有多少行(tableView: numberOfRowsInSection:), 表格中某些行被选中需要怎么样(tableView: didSelectRowAtIndexPath:)
3. respondsToSelector: 方法

# 非正式协议

1. 非正式(informal)协议, 实际上是一个分类, 通常用于根类, 也成为抽象(abstract)协议
2. 非正式协议实际上仅仅是一个名称之下的一组方法, 声明非正式协议的类自己并不实现这些方法
3. 选择实现这些方法的子类需要在它的接口部分重新声明这些方法, 并实现这些方法中的一个或多个
4. 编译器不提供有关非正式协议的帮助, 没有遵守协议或者由编译器测试这样的概念
5. 非正式协议是委托技术的基础

# 合成对象 composite object

1. 定义一个类包含其他类的一个或多个对象(相当于 C++ 的类的组合, 有一个的关系)
2. 初始化合成对象时, 应初始化其包含的对象

# 手工引用计数和自动引用计数(ARC)

1. 手工引用计数需要给对象发送 release 消息, 来释放对象
2. 如果使用自动引用计数, 那么每次调用函数(方法)时, 局部对象的变量都会默认初始化为空 13.2.1

# self 关键字

1. 指明调用该方法的实例对象是当前方法的接收者

# 快速枚举

# 自动释放池 autoreleasepool

# 动态解析方法

# isa 指针

1. isa 指针是对象的隐藏数据, 也是对象的第一个成员变量, 每个对象都会继承这个保护成员, 从根对象获得, 用于确定对象所属的类
2. isa 指针指向一个类对象(class object), 类对象占用内存空间, 在编译的时候生成, 用来描述某个类的定义
3. 类对象包含了 OC 对象的一些信息, 包括 OC 对象的方法调度表，实现了什么协议等等, 这个包含信息就是 OC 动态能力的根源

isa 指针类型的数据结构

```
struct objc_class {
    Class isa;			//指向元类对象(metaclass object)
    Class super_class;	//指向父类的类对象
    const char *name;  
    long version;  
    long info;
    long instance_size;  
    struct objc_ivar_list *ivars;  
    struct objc_method_list **methodLists;   
    struct objc_cache *cache;  
    struct objc_protocol_list *protocols;     
 }  
 ```

# 高阶函数

1. 使用函数指针作为参数的函数有 qsort, 方法有 sortUsingFoundation:context, 可对任意数组进行排序
2. 高阶函数还可以用于分派表 13.5.4

# 参考

书籍

1. 《Objective-C 程序设计》

博客

1. [Objective-C消息发送和消息转发机制](http://www.jianshu.com/p/01a19c64499c)

教程

1. [征战Objective-C](http://www.imooc.com/learn/218)
2. [Objective-C 面向对象初体验](http://www.imooc.com/learn/373)
