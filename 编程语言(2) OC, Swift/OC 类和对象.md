# 类和对象

1. 对象的本质是结构, 对象的实例变量是结构的成员, 继承自父类的实例变量和当前子类对象自身的实例变量将组成新的结构
2. 对象的引用是指向结构的指针, 因此才可以用"->"运算符访问 `@public` 修饰的实例变量(不推荐)
3. 对象的封装的作用是使具体实现不可见，只向用户提供方法调用的接口, 有利于更好的对事物进行抽象, 原则是不能在类外直接访问实例变量, 而是需要 set 和 get 方法, 否则会难以跟踪, 调试和修改
4. 对象是引用类型: 使用 alloc, init 方法或 new 方法(不推荐)实例化对象, 对象都通过对象指针进行引用, 即传址调用
5. 使用 `@class` 声明当前类要用到的类, 可使用该类的属性, 提高效率, 但要使用该类的方法, 则需包含该类的整个头文件
6. 使用 self 关键字指明调用该方法的实例对象是当前方法的接收者

1. 在栈中实例化字符串对象自动释放内存, 在堆中实例化对象需要手动释放内存

```
// 头文件, 类的声明
@interface SimpleClass: NSObject		// 类名, 父类名
{
	@protected							// 实例变量访问限定符
	NSString	*_name;					// 实例变量(更推荐写在实现文件中)
}
@property (readonly) NSString	*name	// 属性
-(void) method;							// 方法
+(id) staticMethod;						// 静态方法
@end

// 源文件, 类的实现
#import "SimpleClass.h"					// 包含类声明的头文件
@implementation ClassName				// 类名
{
	NSString *_name;					// 实例变量
}
-(void) method{							// 方法的实现
	_name = @"string";					// 访问实例变量
	NSLog(@"Hello World");
}
@end
```

# 对象的复制

1. 浅拷贝: 将一个对象赋值给另一个对象时, 仅仅创建了另一个对这个对象的引用
2. 深拷贝: 创建对象的内容的副本, 而不仅是这些对象的引用的副本
3. 对象是否可变并不影响其副本是否可变

# Foundaton 类的方法

1. copy 和 mutableCopy 方法默认执行浅拷贝
2. copy 方法发送 copyWithZone: 消息

# <NSMutableCopying> 协议

1. 要实现自定义的类的复制, 必须根据 <NSCopying> 协议实现其中的某些方法
2. 如果编写一个类的 copyWithZone: 方法, 而该类的超类也实现了 <NSCopying> 协议, 那么应该先调用超类的 copy 方法以复制继承来的实例变量, 然后再加入自己的代码以复制想要添加到该类中的任何附加的实例变量

```
- (id)copyWithZone: (NSZone *) zone		// 返回不可变副本, 参数 zone 与不同的存储区有关, 将空间分配分组到这些存储区中来优化内存分配
mutableCopyWithZone:					// 返回可变副本
```

# 用设值方法和取值方法复制对象

1. 将传入设值方法的对象的不可变副本赋值给对象的成员变量, 避免传入的对象的改变影响对象的成员变量
2. 属性指定了 copy 特性, 则合成的方法会使用类的 copy 方法(不存在 mutableCopy 特性, 因此即使是可变的实例变量, 也是使用 copy 特性, 生成对象的不可变副本)
3. 取值方法如果返回一个可变对象, 则这个可变对象的更改不应影响实例变量的值, 因此可以生成实例变量的副本作为返回值
