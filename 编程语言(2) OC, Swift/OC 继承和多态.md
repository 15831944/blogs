# 继承

1. OC 不支持多继承, 用协议实现类似功能, 子类和父类的成员变量不可重名
2. 私有成员变量不可以被继承, 若父类方法中使用了父类的私有变量, 则可以通过继承父类的方法, 间接的使用父类的私有成员变量
3. 继承来的实例变量是父类实例变量的拷贝, 拥有父类实例变量的值
4. 抽象类(abstract superclasses): 不能实例化, 例如 NSNumber 类, 每个具体子类属于 NSNumber 类, 总称为簇(cluster), 子类是私有的, 只能通过抽象的超类间接访问
5. 初始化子类时应先初始化父类(类似于 C++ 中构造函数需要从继承链父类到子类一级一级的初始化)

# 多态

1. 一个父类可以有多个子类，每个子类在继承了父类的方法后，对该父类方法分别进行重写，那么每个子类的方法是不一样的，一个父类方法被改写成多种形态，叫做多态, 方法名相同, 因此是同一个消息, 接收者不同, 即可以向不同类的对象发送相同的消息
3. 方法重写: 方法的返回值类型, 名称, 参数类型和数量均相同, 使用 super 调用父类方法, 使用 self 调用当前类方法(相当于递归调用), 在分类中覆写方法会导致原方法无法访问
4. 方法重载: 方法名相同的函数互为重载, OC 不支持方法重载, 因此方法的返回值类型和参数类型需要是静态类型, 才能找到正确的方法
5. 使用父类对象指针指向子类对象, 会调用子类的重写的方法
6. id 类型: 不可以使用点运算符
6. 静态类型: 对存储在变量中的对象的类型进行显式声明, 在编译时进行检查
6. 动态类型: 能是程序直到执行时才能确定对象所属的类
7. 动态绑定: 能使程序知道执行时才确定实际要调用的对象方法
8. 使用 class 方法根据类名或另一个对象生成一个类对象
9. selector 是一个 SEL 类型的值, 使用 `@selector` 指令产生, 用于指定方法, 为指定方法生成一个 SEL 类型的值
