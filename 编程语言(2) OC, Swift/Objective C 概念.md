# 概述

1. Objective-C 由 GNU 接管, 可以用于 Linux 嵌入式开发和服务器端开发
2. Objective-C 文件扩展名为".m", 与 C++ 混编的文件扩展名为 ".mm"
3. 面向对象的理念就是将同一个方法应用于不同的对象
4. 框架就是一组从逻辑上组合在一起的类和例程
5. 0, 0x 分别表示八进制和十六进制, f, l, u, ll 前缀用于表示字面值的数据类型
6. NAN 表示不是一个数字, 定义在 math.h 中, NSLog 打印为 nan (6.1节)
7. 在 NSLog 中使用 `%%` 打印 `%`
8. 在 scanf 函数的格式化字符串 "%c" 前面插入一个空格, 可以跳过输入中的空白字符, 以得到期望的字符 (6.1.4节)
9. 使用 ctype.h 中的 islower 函数和 inupper 函数判断字母大小写
1. 条件运算符从右向左结合, Objective-C 支持非 ANSI 扩展的语句:` condition ? : expression`
2. 循环语句分支本质上都是 CPU 控制器的跳转指令
3. switch 语句支持整型, 字符型

```
// 头文件, 类的声明
@interface SimpleClass: NSObject		// 类名, 继承的类名
{
	@protected							// 成员变量访问限定符
	NSString	*_name;					// 成员变量(更推荐写在实现文件中)
}
@property (readonly) NSString	*name	// 属性
-(void) method;							// 方法
+(id) string;							// 静态方法
@end
// 源文件, 类的实现
#import "SimpleClass.h"					// 包含类声明的头文件
@implementation ClassName				// 类名
{
	NSString *_name;					// 成员变量
}
-(void) method{							// 方法的实现
	_name = @"str";						// 访问成员变量
	NSLog(@"Hello World");
}
@end
```

# 数据类型

1. 基本数据类型: int, float, double, char
2. 类型修饰符: long, long long, short, signed, unsigned
3. 整型类型变量默认初始值为0
4. 布尔类型变量本质是"预处理程序"的机制, 使用预定义的值 YES, NO
5. id 类型是多态和动态绑定的基础, nil 是 id 类型, 本质是指针类型, 声明时没有星号, 可以使用强制类型转换将 id 类型转换为特定类型对象
6. instancetype 类型, 决定了基于上下文的返回类型, 被继承时, 可以正确返回子类
7. 枚举数据类型可以在冒号后面指定数据类型
8. 使用编译器选项 `-W Conversion` 和 `-Wswitch`,当赋值和使用枚举类型表达式以及枚举常量应用在 switch 语句时, 提供类型检查

# 变量

1. 普通实例变量: 每个对象都有该变量的拷贝, 在多次方法调用时保持自己的值
2. 普通局部变量: 初始值为 nil, 方法返回即失效, 方法的参数是局部变量
3. 静态局部变量: 初始值为0, 只能通过声明该变量的方法访问, 每个对象访问的是同一个变量
4. 静态实例变量: 所有的方法都可以访问
5. 全局变量: 用 g 开头, 声明不会引起变量存储空间分配, 定义会, 因此 extern 应只用于声明, 不建议用 extern 声明的同时进行定义和初始化, 如果只有少数方法要访问某全局变量, 可以在使用前单独进行 extern 声明, 外部全局变量破坏封装性
6. 

# 类, 对象

1. 使用 alloc, init 方法或 new 方法(不推荐)实例化对象, 对象都通过对象指针进行引用, 即传址调用
2. NSObject 类定义在 NSObject.h 文件中, Foundation.h 文件中包含 NSObject.h
3. 使用 `@class` 声明当前声明的类要用到的类, 可使用该类的属性, 提高效率, 但要使用该类的方法, 则需包含整个头文件

# 属性, 成员变量

1. 成员变量: 使用大括号声明在接口文件`@interface`(公有, 可以被继承)或实现文件`@implementation`(私有)中, 在类内按名称直接访问, 推荐后者方式
2. 属性: 是成员变量的外部接口, 只能在接口文件中声明, 本质是调用 set 和 get 方法访问成员变量, 叫做访问器(accessor)方法(since Objective-C 2.0), 在类外使用 "." 运算符调用方法进行访问
3. 成员变量名是属性名加下划线前缀, 二者内存操作不同, 在实现文件中使用 `@synthesize var = _var` 的形式将成员变量名和, 属性名进行对接
4. 若只在头文件中声明属性, 则会自动生成以下划线开头的同名的成员变量, 不再需要 `@synthesize`
5. 成员变量被访问限定符修饰, 默认为 protected
6. 方法没有访问限定符, 方法的属性类似于 C 语言, 在头文件中声明则具有外部属性, 相当于公有, 可以被继承, 在实现文件中声明则为该类私有, 不能被继承

| qualifier  | 类外                          | 类内               | 继承性 |
| ---------- | ---------------------------- | ------------------ | ----- |
| @public    | 只能使用 "->" 操作符访问(不推荐) | 使用成员变量名直接访问 | 允许 |
| @proteced  | 禁止                          | 使用成员变量名直接访问 | 允许 |
| @private   | 禁止                          | 使用成员变量名直接访问 | 禁止 |
| @package   | 在框架内, 相当于私有            | 在框架外, 相当于受保护 |     |

# 方法

`- (int) showWithA:(int)a andB:(int)b;`

1. 对象方法: 使用对象实例(经过 alloc)进行调用, 可以访问该类的成员变量
2. 类方法(静态方法): 使用类名进行调用, 只能访问静态成员变量
3. 方法声明: "-"表示对象方法, "+"表示静态方法, 参数写在":"后, 返回值类型和参数类型写在"()"中, 函数名包括冒号及变量名后面的空格
4. Init 方法的返回值类型可以是 id (任意对象类型)或 instancetype (当前类的类型)
5. 重写初始化方法: 方法名不变, 对成员变量进行初始化, 返回 self
6. 自定义初始化方法: 以 Init 开头的方法名
7. 取值方法: [instance property] 等价于 instance.property
8. 设值方法: [instance setProperty: value] 等价于 instance.property = value
9. alloc 方法保证对象的所有实例变量都变成初始状态(0值), 但对象未正确初始化, 返回成员数据的首地址
10. init 方法用于初始化类的成员变量
11. new, alloc, copy, init 开头的方法与编译器的一些假定有关
12. 用点运算符访问成员变量, 用方括号调用方法(也可以使用点运算符调用方法, 但不推荐)
17. 强制使用父类调用子类的方法? (8.3.1节)
18. 指定的(designated)初始化方法: 一般为最复杂的, 参数最多的初始化方法, 子类可以重写此方法
19. initialize 方法: 在程序开始时, 向所有的类发送 initialize 调用方法, 只发送一次, 用于初始化与类相关的静态变量

# 消息发送和转发

1. 消息的发送者:
2. 消息的接收者: 请求一个类或实例来执行某个操作时, 就是在向它发送一条消息, 方法执行的上下文环境就是接收到消息的对象
3. 方法的查找: 先查找本类有没有该名称的方法, 没找到则继续查找父类
4. 消息的转发: forwardInvocation: 方法

# 封装

1. 封装的作用是使具体实现不可见，只向用户提供方法调用的接口有利于更好的对事物进行抽象
2. 数据封装的原则就是不能在类外直接设置或获取实例变量的值, 而是需要 set 和 get 方法, 否则会难以跟踪, 调试和修改

# 继承

1. Objective C 不支持多继承, 用协议实现类似功能
2. 私有成员变量不可以被继承, 若父类方法中使用了父类的私有变量, 则可以通过继承父类的方法, 间接的使用父类的私有成员变量
3. 在实现部分声明或合成的实例变量是私有的, 不能被继承
4. 类的每个实例都拥有自己的实例变量, 即使这些实例变量是继承来的, 且拥有父类实例变量的值
5. 子类和父类的成员变量不可重名
6. 抽象类(abstract superclasses): 不能实例化, 例如 NSNumber 类, 每个具体子类属于 NSNumber 类, 总称为簇(cluster), 子类是私有的, 只能通过抽象的超类间接访问
7. 初始化子类时应先初始化父类(构造函数需要从继承链父类到子类一级一级的初始化)

# 多态

1. 一个父类可以有多个子类，每个子类在继承了父类的方法后，对该父类方法分别进行重写，那么每个子类的方法是不一样的，一个父类方法被改写成多种形态，叫做多态, 方法名相同, 因此是同一个消息, 接收者不同, 即可以向不同类的对象发送相同的消息
2. 如果一种语言不支持多态，那么它只能称为基于对象，而不能称为面向对象
3. 方法重写: 方法的返回值类型, 名称, 参数类型和数量均相同, 使用 super 调用父类方法, 使用 self 调用当前类方法(相当于递归调用)
4. 方法重载: 方法名相同的函数互为重载(不支持)
5. 使用父类对象指针指向子类对象, 会调用子类的重写的方法
6. id 类型: 不可以使用点运算符
6. 静态类型: 对存储在变量中的对象的类型进行显式声明, 在编译时进行检查
6. 动态类型: 能是程序直到执行时才能确定对象所属的类
7. 动态绑定: 能使程序知道执行时才确定实际要调用的对象方法
8. 方法的返回值类型和参数类型需要是静态类型, 才能找到正确的方法, 即不支持方法重载
9. 使用 class 方法根据类名或另一个对象生成一个类对象
10. selector 是一个 SEL 类型的值, 使用 `@selector` 指令产生, 用于指定方法, 为指定方法生成一个 SEL 类型的值

# 异常

1. NSException 对象包含异常信息, 作为参数传递给`@ catch` 块
2. `@try`, `@catch`, `@finally`
3. `@throw`

# 模块 module

引用包含在一个源文件中任何数目的方法或者函数定义

# 分类 category

将类的定义模块化到相关的方法的组或分类中, 是更简便的扩展类的方式, 无须访问类的源代码, 无须创建子类

# 手工引用计数和自动引用计数(ARC)

1. 给对象发送 release 消息, 来释放对象

# self 关键字

指明调用该方法的实例对象是当前方法的接收者

# 快速枚举

# 自动释放池 autoreleasepool

# 动态解析方法

# 委托 delegation

respondsToSelector: 方法

# 参考

书籍

《Objective-C 程序设计》

博客

[Objective-C消息发送和消息转发机制](http://www.jianshu.com/p/01a19c64499c)

教程

1. [征战Objective-C](http://www.imooc.com/learn/218)
2. [Objective-C 面向对象初体验](http://www.imooc.com/learn/373)
