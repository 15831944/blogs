# 属性 Properties

属性将值跟特定的类, 结构, 枚举关联, 用于特定类型的实例, 实例之间的属性相互独立, 类属性只有一份

存储属性

1. 存储属性(Stored Properties): 可存储常量或变量作为实例的一部分, 仅用于类, 结构体
2. 延迟存储属性(Lazy Stored Properties): 首次访问时(实例构造完成后的任何时刻)才计算初始值, 必须是变量, 因为常量必须在构造完成前初始化
3. 默认属性值(Default Property Values): 提供默认值作为存储属性定义的一部分, 等同于在构造器中初始化
4. 属性的初始化: 属性必须赋初始值, 要么在声明时初始化默认值, 要么在构造器(Initializer)中初始化, 在构造器中可以设置和修改初始值(即使是常量)
5. 结构体常量: 若结构体是常量, 则即使其成员是变量, 也无法修改该属性, 原因是结构体是值类型, 而类由于是引用类型则可以修改对象常量的属性
6. 属性常量: 若结构体是变量, 但其成员是常量, 则不可以赋值给结构体的常量成员, 但可以整体赋值给结构体, 间接的改变了常量成员的值?
7. 实例变量(Instance Variables): OC 中, 实例变量作为存储属性中的值的后端存储(backing store), Swift 中的属性没有对应的实例变量, 属性的后端存储也无法直接访问

计算属性

1. 计算属性(Computed Properties): 不直接存储值, 不占用内存空间?, 用于类, 结构体, 枚举, 计算属性在构造时无须初始化, 类实例构造完成后, 访问该计算属性时才会进行相应计算
2. getter (必须实现)用来根据其他存储属性值计算而获取计算属性值, 返回一个该类型的立即数
3. setter (可选实现)用来根据传入的 newValue, 间接设置其他存储属性或变量的值, newValue 是隐式的默认参数, 可以省略或自定义, 计算属性无法重载?
2. 只读计算属性(Read-Only Computed Properties): 只有 getter 没有 setter 的计算属性, 在声明中 去掉 set 部分即可, get 也可省略, 计算属性(包括只读计算属性)必须是变量
3. 计算属性无须属性观察器, 直接用 setter 方法

属性观察器

1. 属性观察器(Property Observers): 可以为定义类的及继承的存储属性添加属性观察器, 监控和响应属性值的变化, 触发自定义的操作(即使新值和旧值相同), 适用于非延迟的存储属性
2. 本身不需要计算属性的值, 但需要提供在设置新值之前(后)要执行的代码, 一旦被观察的属性的值在初始化过程以外改变, 属性观察器代码便得以执行
3. willset 观察器: 在为该属性设置新值之前调用, 将新的属性值作为固定参数传入, 默认参数名为 newValue
4. didset 观察器: 在设置新值之后立即调用, 将旧的属性值作为参数传入, 默认参数名为 oldValue, 如果在 didSet 观察器里为属性赋值, 这个值会替换观察器之前设置的值
3. 为属性设置默认值或在构造器中初始化, 都属于直接赋值, 是等效的, 不会触发属性观察器

全局变量和局部变量 Global and Local Variables

1. 全局存储变量和局部存储变量: 可以定义属性观察器
2. 全局计算变量和局部计算变量: 可以用于计算值
3. 全局常量和常量: 类似于延迟存储属性, 是延迟计算的(局部常量和变量不会延迟计算)

类型属性

1. 类型属性不论类型有多少个实例都只有唯一一份, 用于定义特定类型所有实例共享的数据
2. 存储型类型属性: 适用于值类型(结构体, 枚举), 可以是变量或常量, 必须指定默认值, 因为无法使用构造器初始化, 使用 static 关键字声明
3. 计算型类型属性: 适用于值类型和引用类型(结构体, 枚举, 类), 只能是变量, 值在访问时才被初始化, 使用 class 关键字声明
4. 类型属性作为类型定义的一部分写在类型最外层的花括号内, 作用域在类型支持的范围内
5. 作用类似于 OC 中的工厂方法

self 属性

1. 每一个类的实例都具有隐式的 self 属性, 完全等同于该实例本身, 用于在实例方法中引用当前实例
2. 实例方法的参数名和该实例的属性名同名时, 才有必要显式地使用 self 属性以消除歧义, 否则会当作方法的参数处理

# 方法 Methods

1. 方法是与特定类关联的函数, 类, 结构体, 枚举均可定义实例方法和类方法
5. 方法的覆写: 覆写父类实现的子类方法须使用 override 修饰, 不带 override 的覆写会被编译器认为是错误, 编译器也会检测带 override 却没有覆写父类方法的方法
6. 在方法, 属性和下标这样的操作前, 使用 "?", 如果问号前是 nil, 则问号后的一切都被忽略, 且整个表达式的值为 nil. 否则, 可选型被解包, 且问号后的一切使用被解包后的值. 不论哪种情况, 整个表达式的值是一个可选型

实例方法 Instance Methods

1. 实例方法能够隐式地访问它所属类型的所有的其他实例方法和属性, 只能被它所属的类的某个特定实例调用, 不能脱离于现存的实例而被调用
2. 和函数一样, 方法的参数可以具有参数名和参数标签
3. 在实例方法中修改值类型

类型方法 Type Methods

1. 类似于 OC 中的类方法(Class Methods), 使用和类型声明一样的 Class 关键字

变异方法 Mutating



# 构造器 Initializer

1. 类, 结构体, 枚举类型的每个存储型属性的初始化
2. 构造器无须返回值(OC 中的构造器需要返回值), 以 init 开头
3. 构造子类实例的步骤: 设置子类声明的属性的值, 调用父类的初始化函数初始化父类, 再初始化继承自父类的属性, 初始化自身的属性等
4. 构造参数: 函数名相同(都是 init), 参数不同的构造器, 应指定外部参数名
5. 可选型属性在类实例化时会自动赋值为 nil
6. 常量属性也可以在构造函数中赋初始值
7. 默认构造器: 所有属性都有默认值的类在实例化时会调用默认构造器, 自定义构造器将导致默认构造器无法访问, 除非将构造器写到扩展中
8. 逐一成员构造器: 所有成员均有默认值的结构体会自动获得一个逐一成员构造器, 参数名同成员属性名
9. 构造器代理: 调用其他构造器来完成实例的部分构造过程, 减少构造器代码重复
1. 值类型的构造器代理:
2. 引用类型的构造器代理:
3. 指定构造器: 指定构造器将初始化类中提供的所有属性, 并根据父类链往上调用父类的构造器来实现父类的初始化, 每一个类都必须拥有至少一个指定构造器
4. 便利构造器: 便利构造器中可调用同一个类中的指定构造器, 可用于创建一个特殊用途或特定输入的实例

## 构造器链

构造器链用于简化指定构造器和便利构造器之间的调用关系, 指定构造器必须总是向上代理(在复杂的类层次结构中充当管道作用), 便利构造器必须总是横向代理

1. 规则1: 指定构造器必须调用其直接父类的的指定构造器
2. 规则2: 便利构造器必须调用同一类中定义的其它构造器
3. 规则3: 便利构造器必须最终以调用一个指定构造器结束

## 两段式构造过程

1. 两段式构造过程可以防止属性值在初始化之前被访问, 也可以防止属性被另外一个构造器意外地赋予不同的值
2. OC 的两段式构造过程给每一个属性赋 0 值或空值不允许定制初始值

两个阶段

1. 阶段1: 每个存储型属性通过引入它们的类的构造器来设置初始值
2. 阶段2: 在新实例准备使用之前进一步定制它们的存储型属性

安全检查

1. 安全检查1: 指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器
1. 安全检查1:
1. 安全检查1:
1. 安全检查1:

# 析构器

1. 析构函数以 deinit 开头
