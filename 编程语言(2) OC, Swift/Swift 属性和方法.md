# 属性 Properties

1. 属性将值跟特定的类, 结构, 枚举关联
2. 存储属性(Stored Properties): 存储常量或变量作为实例的一部分, 仅由类, 结构体提供, 初始化过程中可以设置和修改初始值(即使是常量)
3. 延迟存储属性(Lazy Stored Properties): 直到首次使用时才计算初始值
4. 属性的初始化: 属性必须赋初始值, 要么在声明时, 要么在构造函数(initializer)中
5. 默认属性值(Default Property Values): 提供默认值作为存储属性定义的一部分
6. 实例变量(Instance Variables): OC 中, 实例变量作为属性中的值的后端存储(backing store), Swift 中的属性没有对应的实例变量, 属性的后端存储也无法直接访问
7. 计算属性(Computed Properties): 计算(而不是存储)一个值, 由类, 结构体,枚举提供, 提供一个 getter 和一个可选的 setter 来间接获取或设置其他属性或变量的值, 无法重载, 设值方法(setter)的新值的隐式名称是 newValue
8. 只读计算属性(Read-Only Computed Properties):
9. 属性观察器(Property observers): 可被添加到定义类及其子类的存储属性, 监控和响应属性值的变化, 每次属性被设置值的时候都会调用属性观察器, 计算属性无须属性观察器, 直接用 setter 方法, didset 和 willset 方法不需要计算属性的值, 但需要提供在设置新值之前(后)要执行的代码, 一旦值在初始化函数以外改变, 代码便得以执行
1. 全局和本地变量(Global and Local Variables):
2. 类型属性(Type Properties): 静态属性
3. 结构体常量: 若结构体是常量, 则即使其成员是变量, 也无法修改该属性, 原因是结构体是值类型, 而类由于是引用类型则可以修改对象常量的属性
4. 属性常量: 若结构体是变量, 但其成员是常量, 则不可以赋值给结构体的常量成员, 但可以整体赋值给结构体, 间接的改变了常量成员的值?
5. self 属性: self 完全等同于该实例本身

# 方法

1. 实例方法(Instance Methods): 实例方法能够隐式访问它所属类型的所有的其他实例方法和属性, 只能被它所属的类的某个特定实例调用, 不能脱离于现存的实例而被调用
2. 类型方法(Type Methods): 类似于 OC 中的类方法(Class Methods), 使用和类型声明一样的 Class 关键字
3. 变异方法(Mutating):
4. 类, 结构体, 枚举均可定义实例方法和类方法
5. 方法的覆写: 覆写父类实现的子类方法须使用 override 修饰, 不带 override 的覆写会被编译器认为是错误, 编译器也会检测带 override 却没有覆写父类方法的方法
6. 在方法, 属性和下标这样的操作前, 使用 "?", 如果问号前是 nil, 则问号后的一切都被忽略, 且整个表达式的值为 nil. 否则, 可选型被解包, 且问号后的一切使用被解包后的值. 不论哪种情况, 整个表达式的值是一个可选型

# 构造器

1. 构造函数以 init 开头
2. 构造子类实例的步骤: 设置子类声明的属性的值, 调用父类的初始化函数初始化父类, 再初始化继承自父类的属性, 初始化自身的属性等

# 析构器

1. 析构函数以 deinit 开头
