# 自动引用计数 ARC

1. ARC 机制的作用: Swift 使用自动引用计数机制跟踪和管理应用程序的内存使用情况, 负责在创建类的实例时分配内存, 用于存储实例的类型信息和属性值, 在类的实例不再需要时, 自动释放其内存, 引用计数仅适用于引用类型, 即类的实例, 值类型(结构体, 枚举等)不需要引用
2. ARC 机制的实现: ARC 机制对强引用进行计数, 若强引用存在, 实例就不会被释放, 若强引用计数为0, 即不再存在指向该实例的强引用时, 则释放类实例
3. 强引用: 引用一个实例并保持强引用(a firm hold), 强引用的实例可能存在或不存在, 因此应使用可选型变量引用该实例, 一个实例的属性也使用可选型变量引用另一个实例, 给可选型变量的强引用属性赋值要先对可选型强制展开, 强弱表征的是释放该对象的条件的强弱
4. 强引用的创建: 可选型变量被类实例赋值, 即引用该实例时, 会对此实例创建强引用, 多个变量引用同一个类实例会创建多个强引用
5. 强引用的断开: 将可选型变量赋值为 nil 即断开引用
6. 类实例循环强引用: 两个类实例互相保持对方的强引用, 使得对方不能被销毁, 导致强引用计数永远不会为0, 即引用类实例的变量虽然可以断开, 但两个实例本身还保持着对方的强引用
7. 弱引用: 引用实例但不保持强引用(a strong hold), 对在生命周期中会变为 nil 的实例使用弱引用, 弱引用必须是变量才有可能变为 nil, 不能是常量, ARC 机制会在实例被销毁后自动将弱引用赋值为 nil, 检查弱引用的值, 即可避免访问已被销毁的实例, 循环引用的两个实例中, 被弱引用的实例先被销毁后, 该对象对其他对象的强引用自然也会消失, 然后另一个实例被销毁, 弱引用适用于两个实例的属性都可能为 nil 的情况
8. 无主引用: 引用实例但不保持强引用(a strong hold), 对初始化后确保不会变为 nil 的实例使用无主引用, 无主引用一直有值, 不能被定义为可选型, 因此总是可以被直接访问, 但无法在引用的对象实例被销毁后被 ARC 机制赋值为 nil, 此时会触发运行时错误, 无主引用的属性应在该类被实例化时被初始化, 即应将某个实例通过构造器参数传入, 确保无主属性有值, 循环引用的两个实例中, 被无主引用的实例先被销毁, 无主引用适用于两个实例的属性一个可能为 nil, 另一个不能为 nil 的情况, 实例化有无主引用属性的类时, 另一个只具有强引用属性的类可以被单独实例化, 无主引用可以是常量
9. 无主属性和隐式解析可选属性: 适用于两个实例的属性均必须有值, 即初始化后不能为 nil 的情况, 即循环引用的两个类想要实例化需要对方已经实例化, 无主引用由于不是可选型, 可以被直接访问, 隐式解析可选型由于自动展开, 也可以直接访问, 两者均可以是常量, 解决A在实例化时, 在其构造器中需要实例化B, 而B的实例化又需要A, 导致A实例化却需要已经实例化的A的问题, 解决方式是将A中的B属性声明为隐式解析可选型, 因为其具有默认值 nil, 最终通过一条语句就能同时创建两个实例, 且不产生循环强引用

1. 闭包循环强引用: 实例的属性要使用闭包进行初始化, 而这个闭包体中又使用了该实例(访问了实例的某些属性或方法), 闭包需要捕获 self, 产生循环强引用, 本质原因是闭包和类一样均是引用类型,
2. 闭包占用列表: 
