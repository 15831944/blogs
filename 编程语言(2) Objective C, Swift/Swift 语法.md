# 常量和变量

1. 数据对象的声明: 使用 let 声明常量(constant), 使用 var 声明变量(variable)
2. 类型推断(type inference): 根据初始值隐式地判断数据对象的类型
3. 显式数据据类型声明: 使用":"指定声明的数据类型
4. 常量的初始化: 声明常量后可以不赋初始值, 将后面第一次赋值作为该常量值, 常量声明但未初始化期间不可以使用
5. 常量和变量的存储: 将常量提到与变量对等的位置, 避免可以使用常量的地方使用变量, 常量存储在内存中的常量区, 效率更高

# 基本数据结构类型

1. 基本数据类型包括: Int(UInt, Int8), Float(CGFloat), Double, Bool, String, Tuple
2. 基本数据类型的本质是结构, 自定义数据类型则为类, 类型名风格为首字母大写

## 整型 Int, UInt, Int8, Int64

1. Int 结构成员: 使用 Int.max 和 Int.min, 查看整型的存储范围
2. 不同进制数: 使用 0b, 0o, 0x 表示不同进制的整型字面值
3. 声明大数字: 使用下划线将整型字面值进行分割, 便于阅读

## 浮点型 Float, Double

1. Float 类型为32位数, Double 类型为64位数(默认)
2. 可以使用科学计数法初始化浮点类型变量
3. 使用 CGFloat 类型表示图形中的浮点数(Core Graphics 是苹果的一个底层矢量图绘制框架, 还有 Core Data，Core Animation 等)
4. Swift3 引入 FloatingPoint 协议统一不同的浮点类型

## 布尔 Bool

1. true, false
2. 不可以使用非0值代表真

## 元组 Tuple

1. 解包: 将元组中的分量"分解出来"赋给各变量, 使用下划线忽略不需要解包的分量
2. 分量的名称: 使用":"在初始值中或显式类型声明中为元组的各分量命名
3. 分量的访问: 使用.运算符以分量的序号或名称访问各分量

# 可选型 option

1. 不应使用同类型中的特殊值代表"没有"这个概念, 例如用整型值404代表错误, 用0代表没有错误, 是有弊端的, 而应使用统一的符号代表"没有"这个概念
2. swift 使用 nil 代表"没有", 它是可选型(单独的类型), 不像其他语言中, NULL 的本质还是整型
3. 可选型的声明: 可选型必须和其他类型共存, 必须显式声明可选型, 使用类型名接问号, 例如 Int? 代表整型的可选型, 即该类型的变量可选为整型, 也可选为 nil
4. 可选型一般为变量, 而不会是常量, 整型可以赋值给整型的可选型, 反之则不行
2. 没有值时为nil（oc 中 nil 表示空指针，swift 中则更为广泛）
3. 注意，没有被初始化的值不能被直接引用，而非随机值
可选型的解包

1. 由于可选型可能为 nil, 因此需要解包(unwrap), 不能直接使用, 例如在 C++中, 程序执行时, 发现指针指向的对象是空的, 会导致程序崩溃
2. 强制解包: 使用 "!" 强制解包, 但对 nil 强制解包会报编译错误
3. if let 解包: 使用解包后的结果作为条件判断式, 若解包成功, 则说明解包值不是 nil, 可以使用 val, 但程序一般不会去修改解包出来的值, 解包后的值的作用域是语句块内
4. 使用逗号分隔, 进行多个可选型的解包, 使用 where 匹配样式

Optional Binding

将判断和解包结合在一起

Optional Chaining

1. 使用?.或.!使可选型能够调用该类型的方法, 前者是尝试解包, 若解包成功则可以调用方法, 若失败则返回 nil, 后者是强制解包, 若失败则编译错误

nil coalesce

# 集合 Collections

## 数组 Array

1. 使用[]初始化数组, 数组元素(element)使用逗号分隔, 数组元素类型应一致, 但可以是 NSObject 类型, 这样就可以既有整数, 又有字符串了
2. 整型数组的数据类型为[Int], 字符串数组的数据类型为[String], 即将数组元素类型用方括号括起来, 两者是不同类型的数组
3. 数组下标越界会报执行错误()

数组的初始化

```
var arr = []				// 即不指定类型, 也不初始化, 则为 NSString 类型, 不建议使用
var arr: [Int] = []
var arr: Array<Int> = []					// 泛型
var arr: Array<Int> = [1, 2, 3]
var arr = [Int]()							// 构造函数
var arr = [Int] (repeating: 0, count: 5) 	// 重复的值可以是任意类型
var arr = Array<Int>()
var arr = Array<Int> (repeating: 0, count: 3)
```

数组的成员变量(V): count, isEmpty, first, last

数组的方法(M): min(), max(), contains(), indexOf(), enumerate(), append(), insert()

1. 数组元素的添加: append 的参数是字符串, += 操作符的操作数是数组

数组的范围: 

数组的遍历:

数组的比较: 其他语言中, == 判断的是数组的引用是否相等, 而 swift 可以比较数组的值是否相等, 跟比较整数和字符串是类似的

二维数组: 即数组元素本身为数组

类型: [[Int]], [Array<Int>], Arrat<Array<>>, 

## 字典 Dictionary

## 集合 Set

# 自定义数据类型

## 枚举

## 结构体

1. 结构体成员是常量, 但结构体本身是变量, 则不可以赋值给成员, 但可以赋值给结构体, 间接的改变了常量成员的值
2. 结构体的构造函数的参数的顺序需与结构体中成员定义顺序一致, 调用时要么没有参数, 要么参数要全
3. 结构体成员可以具有默认值

# 运算符

1. 赋值语句的返回值由于类型不匹配(Swift中是"()"类型)不可以用作 if 中的条件判断, Java中是因为赋值语句没有返回值
2. Swift3中, %（求余运算符）不能再用于浮点数中, ++ 和 -- 两个操作符正式被弃用
3. 单目运算符和操作数之间不能有空格
4. 引用的比较运算符为 "===" 和 "!=="
5. 与逻辑优先级高于或, 逻辑运算符遵循最短路原则

## 区间运算符

1. 闭区间运算符, [a, b] 表示为 a...b
2. 前闭后开区间运算符, [a, b) 表示为 a..<b, 相当于 0 到 len-1

# 控制流

1. 条件表达式不需要括号, 语句块必须有大括号

## 循环

3. for in 循环跟常量(每次循环时重新定义并初始化, 而非一个变量的值在改变), 必须将区间中的值遍历一遍
5. repeat-while, 至少执行一次
6. swith 语句不需要写 break(可以写, 例如在 default 下不做任何处理时), 一个 case 中可以有使用逗号分隔的多个值, switch 可以判断整数以外的类型, case 需要穷举, 否则必须有 default
7. 使用空的小括号作为空语句, 而不能是分号
8. swith 不仅可以判断单值, 也可以是区间, 元组等
9. 使用 fallthrough 继续判断下一个 case
10. break 或 continue 接控制过程名字可以跳出多重循环或其他的控制转移, 相当于 goto
11. 控制转移包括: break, continue, fallthrough, return, throw
12. where 关键字 限定 case 的匹配模式, 3.0中换成逗号
12. if case

# 参考

1. [玩儿转 Swift](http://www.imooc.com/learn/127)
2. [玩儿转Swift 2.0（第一季)](http://www.imooc.com/learn/635)
3. [玩儿转Swift 2.0（第二季)](http://www.imooc.com/learn/642)
4. [玩儿转Swift 2.0（第三季)](http://www.imooc.com/learn/663)
5. [玩儿转Swift 2.0（第四季)](http://www.imooc.com/learn/677)
